!**********************************************************************************************************************************
!> ## KFC
!! The KiteFastController  module implements a controller for the KiteFAST code. 
!! KiteFastController_Types will be auto-generated by the FAST registry program, based on the variables specified in the
!! KiteFastController_Registry.txt file.
!!
! ..................................................................................................................................
!! ## LICENSING 
!! Copyright (C) 2019  National Renewable Energy Laboratory
!!
!!    This file is part of KiteFAST.
!!
!! Licensed under the Apache License, Version 2.0 (the "License");
!! you may not use this file except in compliance with the License.
!! You may obtain a copy of the License at
!!
!!     http://www.apache.org/licenses/LICENSE-2.0
!!
!! Unless required by applicable law or agreed to in writing, software
!! distributed under the License is distributed on an "AS IS" BASIS,
!! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!! See the License for the specific language governing permissions and
!! limitations under the License.
!**********************************************************************************************************************************
module KiteFastController

   use KiteFastController_Types
   use NWTC_Library
   use, intrinsic :: ISO_C_Binding
   
   implicit none
   private
   
   integer,        parameter    :: IntfStrLen  = 1025       ! length of strings through the C interface
   type(ProgDesc), parameter    :: KFC_Ver = ProgDesc( 'KiteFastController', '', '' )

      !> Definition of the DLL Interface for the KiteFast Controller
      !! 
   abstract interface
      subroutine KFC_DLL_Init_PROC ( dt, numFlaps, numPylons, rtrIrot, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg )  BIND(C)
         use, intrinsic :: ISO_C_Binding
         real(C_DOUBLE), value,  intent(in   ) :: dt                  !< required simulation time step
         integer(C_INT), value,  intent(in   ) :: numFlaps            !< number of flaps per wing in the Kite model
         integer(C_INT), value,  intent(in   ) :: numPylons           !< number of pylons per wing in the Kite model
         real(C_DOUBLE),         intent(in   ) :: rtrIrot(*)          !< The rotor rotational inertias (m^3), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: genTorq(*)          !< The initial generator torques, specified as Top Rotor then Bottom Rotor for inboard Starboard pylon, 
                                                                      !<   then repeat moving outboard.  Then repeat for port side, starting inboard and moving outboard.
         real(C_DOUBLE),         intent(inout) :: rtrSpd(*)           !< The initial rotor speeds (rad/s), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: rtrAcc(*)           !< The initial rotor accelerations (rad/s^2), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: rtrBladePitch(*)    !< The initial rotor-collective blade pitch angles (rad), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: ctrlSettings(*)     !< The initial control surfaces angles(rad), Starts with starboard wing flaps (numFlaps of them), then port wing flaps, 
                                                                      !<   then 2 rudder values, then 2 starboard elevators, then 2 port elevators.
         integer(C_INT),         intent(  out) :: errStat             !< error status code (uses NWTC_Library error codes)
         character(kind=C_CHAR), intent(inout) :: errMsg          (*) !< Error Message from DLL to simulation code        
      end subroutine KFC_DLL_Init_PROC   
   end interface   

   abstract interface
      subroutine KFC_DLL_Step_PROC ( t_c, dcm_g2b_c, pqr_c, acc_norm_c, Xg_c, Vg_c, Vb_c, Ag_c, Ab_c, rho_c, apparent_wind_c, &
         tether_forceb_c, wind_g_c, aeroTorq, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg )  BIND(C)
         use, intrinsic :: ISO_C_Binding
         real(C_DOUBLE), value,  intent(in   ) :: t_c                 !<simulation time (s)
         real(C_DOUBLE),         intent(in   ) :: dcm_g2b_c(9)
         real(C_DOUBLE),         intent(in   ) :: pqr_c(3)          
         real(C_DOUBLE),         intent(in   ) :: acc_norm_c    
         real(C_DOUBLE),         intent(in   ) :: Xg_c(3)           
         real(C_DOUBLE),         intent(in   ) :: Vg_c(3)           
         real(C_DOUBLE),         intent(in   ) :: Vb_c(3)           
         real(C_DOUBLE),         intent(in   ) :: Ag_c(3)           
         real(C_DOUBLE),         intent(in   ) :: Ab_c(3)           
         real(C_DOUBLE),         intent(in   ) :: rho_c          
         real(C_DOUBLE),         intent(in   ) :: apparent_wind_c(3)
         real(C_DOUBLE),         intent(in   ) :: tether_forceb_c(3) 
         real(C_DOUBLE),         intent(in   ) :: wind_g_c(3) 
         real(C_DOUBLE),         intent(in   ) :: aeroTorq(*)           !< The aerodynamic torques.  See genTorq, below for ordering.
         real(C_DOUBLE),         intent(inout) :: genTorq(*)            !< The generator torques, specified as Top Rotor then Bottom Rotor for inboard Starboard pylon, 
                                                                        !<   then repeat moving outboard.  Then repeat for port side, starting inboard and moving outboard.
         real(C_DOUBLE),         intent(inout) :: rtrSpd(*)             !< The rotor speeds (rad/s), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: rtrAcc(*)             !< The rotor accelerations (rad/s^2), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: rtrBladePitch(*)      !< The rotor-collective blade pitch angles (rad), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: ctrlSettings(*)       !< The control surfaces angles(rad), Starts with starboard wing flaps (numFlaps of them), then port wing flaps, 
                                                                        !<   then 2 rudder values, then 2 starboard elevators, then 2 port elevators.
         integer(C_INT),         intent(inout) :: errStat               !< error status code (uses NWTC_Library error codes)
         character(kind=C_CHAR), intent(inout) :: errMsg(1025)          !< Error Message from DLL to simulation code        
      end subroutine KFC_DLL_Step_PROC                                  
   end interface   
 
   abstract interface
      subroutine KFC_DLL_END_PROC ( errStat, errMsg )  BIND(C)
         use, intrinsic :: ISO_C_Binding
         integer(C_INT),         intent(  out) :: errStat             !< error status code (uses NWTC_Library error codes)
         character(kind=C_CHAR), intent(inout) :: errMsg          (*) !< Error Message from DLL to simulation code        
      end subroutine KFC_DLL_END_PROC   
   end interface   

   public :: KFC_Init                     ! Initialization routine
   public :: KFC_End                      ! Ending routine (includes clean up)
   public :: KFC_Step                     ! Routine for computing outputs and internally updating states
  
   contains   
   
   subroutine MapKFCOutputs( numFlaps, numPylons, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, y)
      integer(IntKi),       intent(in   ) :: numFlaps
      integer(IntKi),       intent(in   ) :: numPylons
      real(C_DOUBLE),       intent(in   ) :: genTorq(:)
      real(C_DOUBLE),       intent(in   ) :: rtrSpd(:)
      real(C_DOUBLE),       intent(in   ) :: rtrAcc(:)
      real(C_DOUBLE),       intent(in   ) :: rtrBladePitch(:)
      real(C_DOUBLE),       intent(in   ) :: ctrlSettings(:)
      type(KFC_OutputType), intent(inout) :: y
      
      integer(IntKi)                :: wingOffset, i, j, c
      
         ! Set outputs to zero for now
      c = 1
      wingOffset = 2*numPylons
      do j=1,numPylons
         do i=1,2
            y%SPyGenTorque(i,j) = genTorq(c)
            y%PPyGenTorque(i,j) = genTorq(c + wingOffset)
            y%SPyRtrSpd(i,j)    = rtrSpd(c)
            y%PPyRtrSpd(i,j)    = rtrSpd(c + wingOffset)
            y%SPyRtrAcc(i,j)    = rtrAcc(c)
            y%PPyRtrAcc(i,j)    = rtrAcc(c + wingOffset)
            y%SPyBldPitch(i,j)  = rtrBladePitch(c)
            y%PPyBldPitch(i,j)  = rtrBladePitch(c + wingOffset)
            c = c + 1
         end do
      end do
      
      y%SFlp         = ctrlSettings(1:numFlaps)
      y%PFlp         = ctrlSettings(numFlaps+1:2*numFlaps)
      y%Rudr         = ctrlSettings(2*numFlaps+1:2*numFlaps+2)
      y%SElv         = ctrlSettings(2*numFlaps+3:2*numFlaps+4)
      y%PElv         = ctrlSettings(2*numFlaps+5:2*numFlaps+6)
         
   end subroutine MapKFCOutputs 
   
   subroutine MapDummyKFCOutputs( numFlaps, numPylons, SPyAeroTorque, PPyAeroTorque, rtrSpd, rtrAcc, rtrBladePitch, y)
      integer(IntKi),       intent(in   ) :: numFlaps
      integer(IntKi),       intent(in   ) :: numPylons
      real(ReKi),           intent(in   ) :: SPyAeroTorque(:,:)
      real(ReKi),           intent(in   ) :: PPyAeroTorque(:,:)
      real(ReKi),           intent(in   ) :: rtrSpd
      real(ReKi),           intent(in   ) :: rtrAcc
      real(ReKi),           intent(in   ) :: rtrBladePitch
      type(KFC_OutputType), intent(inout) :: y
      
      integer(IntKi)                :: j
      real(ReKi)                    :: sgn   ! sign for rotor
         ! Set outputs to zero for now
      sgn = -1.0
      do j=1,numPylons
         y%SPyGenTorque(1,j) = -SPyAeroTorque(1,j)
         y%SPyGenTorque(2,j) = -SPyAeroTorque(2,j)
         y%PPyGenTorque(1,j) = -PPyAeroTorque(1,j)
         y%PPyGenTorque(2,j) = -PPyAeroTorque(2,j)
         y%SPyRtrSpd(1,j)    = sgn*rtrSpd
         y%SPyRtrSpd(2,j)    = -sgn*rtrSpd
         y%PPyRtrSpd(1,j)    = sgn*rtrSpd
         y%PPyRtrSpd(2,j)    = -sgn*rtrSpd
         y%SPyRtrAcc(1,j)    = sgn*rtrAcc
         y%SPyRtrAcc(1,j)    = -sgn*rtrAcc
         y%PPyRtrAcc(1,j)    = sgn*rtrAcc
         y%PPyRtrAcc(1,j)    = -sgn*rtrAcc
         y%SPyBldPitch(1,j)  = rtrBladePitch
         y%SPyBldPitch(2,j)  = rtrBladePitch
         y%PPyBldPitch(1,j)  = rtrBladePitch
         y%PPyBldPitch(2,j)  = rtrBladePitch
         sgn = -sgn
      end do
      
      y%SFlp         = 0.0_ReKi
      y%PFlp         = 0.0_ReKi
      y%Rudr         = 0.0_ReKi
      y%SElv         = 0.0_ReKi
      y%PElv         = 0.0_ReKi
         
   end subroutine MapDummyKFCOutputs 
   
   subroutine KFC_End(p, errStat, errMsg)

      type(KFC_ParameterType),        intent(inout)  :: p               !< Parameters
      integer(IntKi),                 intent(  out)  :: errStat         !< Error status of the operation
      character(*),                   intent(  out)  :: errMsg          !< Error message if ErrStat /= ErrID_None

         ! local variables
      character(*), parameter                        :: routineName = 'KFC_End'
      integer(IntKi)                                 :: errStat2       ! The error status code
      character(ErrMsgLen)                           :: errMsg2        ! The error message, if an error occurred
      procedure(KFC_DLL_END_PROC),pointer            :: DLL_KFC_End_Subroutine       ! The address of the controller cc_end procedure in the DLL
      character(kind=C_CHAR)                         :: errMsg_c(IntfStrLen)
      errStat = ErrID_None
      errMsg= ''
      
      if (.not. p%useDummy) then
            ! Call the DLL's end subroutine:
         call C_F_PROCPOINTER( p%DLL_Trgt%ProcAddr(3), DLL_KFC_End_Subroutine) 
         call DLL_KFC_End_Subroutine ( errStat, errMsg_c ) 
         call c_to_fortran_string(errMsg_c, errMsg)
      
         print *, " KFC_End errStat - ", errStat, " errMsg - ", trim(errMsg)

         ! TODO: Check errors
      
            ! Free the library
         call FreeDynamicLib( p%DLL_Trgt, errStat2, errMsg2 )  
            call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      end if
      
   end subroutine KFC_End

   subroutine KFC_Init(InitInp, u, p, y, interval, errStat, errMsg )

      type(KFC_InitInputType),      intent(in   )  :: InitInp     !< Input data for initialization routine
      type(KFC_InputType),          intent(inout)  :: u           !< An initial guess for the input
      type(KFC_ParameterType),      intent(  out)  :: p           !< Parameters
      type(KFC_OutputType),         intent(  out)  :: y           !< Initial system outputs 
      real(DbKi),                   intent(inout)  :: interval    !< Coupling interval in seconds: 
                                                                  !<   Input is the timestep size requested by caller, returned is the Controller's required timestep
      integer(IntKi),               intent(  out)  :: errStat     !< Error status of the operation
      character(*),                 intent(  out)  :: errMsg      !< Error message if errStat /= ErrID_None
 
         ! local variables
      character(*), parameter                 :: routineName = 'KFC_Init'
      integer(IntKi)                          :: errStat2                     ! The error status code
      character(ErrMsgLen)                    :: errMsg2                      ! The error message, if an error occurred
      procedure(KFC_DLL_Init_PROC),pointer    :: DLL_KFC_Init_Subroutine       ! The address of the controller cc_init procedure in the DLL
      
      character(kind=C_CHAR)                  :: errMsg_c(IntfStrLen)
      real(C_DOUBLE), allocatable             :: rtrIrot(:), genTorq(:), rtrSpd(:), rtrAcc(:), rtrBladePitch(:), ctrlSettings(:)
      real(C_DOUBLE)                          :: dt_c
      integer(IntKi)                          :: wingOffset, i, j, c
      real(ReKi), allocatable                 :: SPyAeroTorque(:,:), PPyAeroTorque(:,:)
      errStat2 = ErrID_None
      errMsg2  = ''
   
      call DispNVD( KFC_Ver )  ! Display the version of this interface
      
         ! Check that key Kite model components match the requirements of this controller interface.
      !=============================================================================================
      ! NOTE: GJH: Perhaps a better design is to let the actual controller (shared object) determine if numFlaps and numPylons and interval are acceptable
      !
      !if (InitInp%numFlaps /= 3) call SetErrStat( ErrID_Fatal, 'The current KiteFAST controller interface requires numFlaps = 3', errStat, errMsg, routineName )
      !if (InitInp%numPylons /= 2) call SetErrStat( ErrID_Fatal, 'The current KiteFAST controller interface requires numPylons = 2', errStat, errMsg, routineName )
      !if (.not. EqualRealNos(interval, 0.01_DbKi)) call SetErrStat( ErrID_Fatal, 'The current KiteFAST controller interface requires DT = 0.01 seconds', errStat, errMsg, routineName )
      !   if (errStat >= AbortErrLev ) return
      !=============================================================================================  
      
               ! Set the module's parameters
      p%numFlaps  = InitInp%numFlaps
      p%numPylons = InitInp%numPylons
      interval    = 0.01_DbKi          ! Forcing a controller dt of 0.01 sec
      p%DT        = interval            
      p%useDummy  = InitInp%useDummy
      
         ! allocate the inputs and outputs
      call AllocAry( u%SPyAeroTorque, 2, p%numPylons, 'u%SPyAeroTorque', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( u%PPyAeroTorque, 2, p%numPylons, 'u%PPyAeroTorque', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%SPyGenTorque,  2, p%numPylons, 'y%SPyGenTorque',  errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PPyGenTorque,  2, p%numPylons, 'y%PPyGenTorque',  errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )   
      call AllocAry( y%SPyRtrSpd,     2, p%numPylons, 'y%SPyRtrSpd',     errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PPyRtrSpd,     2, p%numPylons, 'y%PPyRtrSpd',     errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )  
       call AllocAry( y%SPyRtrAcc,     2, p%numPylons, 'y%SPyRtrAcc',     errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PPyRtrAcc,     2, p%numPylons, 'y%PPyRtrAcc',     errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )  
      call AllocAry( y%SPyBldPitch,   2, p%numPylons, 'y%SPyBldPitch',   errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PPyBldPitch,   2, p%numPylons, 'y%PPyBldPitch',   errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )   
      call AllocAry( y%SFlp, p%numFlaps, 'y%SFlp', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PFlp, p%numFlaps, 'y%PFlp', errStat2, errMsg2 )   
         
      if (errStat >= AbortErrLev ) return

      call AllocAry(SPyAeroTorque, 2, p%numPylons, 'SPyAeroTorque', errStat2,errMsg2)
         call SetErrStat(errStat2,errMsg2,errStat,errMsg,routineName)
      call AllocAry(PPyAeroTorque, 2, p%numPylons, 'PPyAeroTorque', errStat2,errMsg2)
         call SetErrStat(errStat2,errMsg2,errStat,errMsg,routineName)
      SPyAeroTorque = 0.0_ReKi
      PPyAeroTorque = 0.0_ReKi
	  
      ! Are we simply using a dummy controller?  If so, we will skip trying to call into a DLL/SO      
      
      if (.not. p%useDummy) then
     
            ! Define and load the DLL:
         p%DLL_Trgt%FileName = InitInp%DLL_FileName

         p%DLL_Trgt%ProcName = "" ! initialize all procedures to empty so we try to load only one
         p%DLL_Trgt%ProcName(1) = 'kfc_dll_init'
         p%DLL_Trgt%ProcName(2) = 'kfc_dll_step'
         p%DLL_Trgt%ProcName(3) = 'kfc_dll_end'
      
         call LoadDynamicLib ( p%DLL_Trgt, errStat2, errMsg2 )
            call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
         if (errStat >= AbortErrLev ) return

         ! Now that the library is loaded, call the controller's kfc_dll_init routine

            ! Call the DLL (first associate the address from the procedure in the DLL with the subroutine):
         call C_F_PROCPOINTER( p%DLL_Trgt%ProcAddr(1), DLL_KFC_Init_Subroutine) 
      
         allocate(rtrIrot(p%numPylons*4), stat = errStat)
         allocate(genTorq(p%numPylons*4), stat = errStat)
         allocate(rtrSpd(p%numPylons*4), stat = errStat)
         allocate(rtrAcc(p%numPylons*4), stat = errStat)
         allocate(rtrBladePitch(p%numPylons*4), stat = errStat)
         allocate(ctrlSettings(p%numFlaps*2+6), stat = errStat)
         
         dt_c = real(0.01, C_DOUBLE)  ! This is hardcoded for the Makani Controller
         
         c = 1
         wingOffset = 2*p%numPylons
         do j=1,p%numPylons
            do i=1,2
               rtrIrot(c)              = InitInp%SPyRtrIrot(i,j)
               rtrIrot(c + wingOffset) = InitInp%PPyRtrIrot(i,j)
               c = c + 1
            end do
         end do
            
         call DLL_KFC_Init_Subroutine ( dt_c, p%numFlaps*2+2, p%numPylons, rtrIrot, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg_c ) 
      
         call c_to_fortran_string(errMsg_c, errMsg)
         print *, " KFC_Init errStat - ", errStat, " errMsg - ", trim(errMsg)
         ! TODO: Check errors
         print *, " debug marker - pre errStat >= Abort"
         if (errStat >= AbortErrLev ) return
         
         print *, " debug marker - post errStat >= Abort"
         print *, " debug - genTorq     : ", genTorq
         print *, " debug - rtrSpd      : ", rtrSpd
         print *, " debug - ctrlSettings: ", ctrlSettings
         
         ! obtain initial outputs from the DLL and set them
         !call MapKFCOutputs( p%numFlaps, p%numPylons, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, y)
            ! This uses the Dummy controller to set the outputs for KiteFAST, the 3 values are rotor speed, rotor acceleration, and blade pitch
         call MapDummyKFCOutputs( p%numFlaps, p%numPylons, SPyAeroTorque, PPyAeroTorque, 120.0_ReKi, 0.0_ReKi, 0.0_ReKi, y)
      else
            ! This uses the Dummy controller to set the outputs for KiteFAST, the 3 values are rotor speed, rotor acceleration, and blade pitch
         call MapDummyKFCOutputs( p%numFlaps, p%numPylons, SPyAeroTorque, PPyAeroTorque, 120.0_ReKi, 0.0_ReKi, 0.0_ReKi, y)
         
      end if

   end subroutine KFC_Init

   subroutine KFC_Step(t, u, p, y, errStat, errMsg )
      real(DbKi),                    intent(in   )  :: t           !< Current simulation time in seconds
      type(KFC_InputType),           intent(in   )  :: u           !< Inputs at Time t
      type(KFC_ParameterType),       intent(in   )  :: p           !< Parameters
      type(KFC_OutputType),          intent(inout)  :: y           !< Outputs computed at t (Input only so that mesh con-
                                                                   !!   nectivity information does not have to be recalculated)
      integer(IntKi),                intent(  out)  :: errStat     !< Error status of the operation
      character(*),                  intent(  out)  :: errMsg      !< Error message if ErrStat /= ErrID_None
   
      character(*), parameter                       :: routineName = 'KFC_Step'
      integer(IntKi)                                :: errStat2       ! The error status code
      character(ErrMsgLen)                          :: errMsg2        ! The error message, if an error occurred     
      procedure(KFC_DLL_Step_PROC),pointer          :: DLL_KFC_Step_Subroutine              ! The address of the supercontroller sc_calcoutputs procedure in the DLL
      real(C_DOUBLE)                                :: t_c
      real(C_DOUBLE)                                :: dcm_g2b_c(9)
      real(C_DOUBLE)                                :: pqr_c(3)
      real(C_DOUBLE)                                :: acc_norm_c
      real(C_DOUBLE)                                :: Xg_c(3)
      real(C_DOUBLE)                                :: Vg_c(3)
      real(C_DOUBLE)                                :: Vb_c(3)
      real(C_DOUBLE)                                :: Ag_c(3)
      real(C_DOUBLE)                                :: Ab_c(3)
      real(C_DOUBLE)                                :: rho_c          
      real(C_DOUBLE)                                :: apparent_wind_c(3)
      real(C_DOUBLE)                                :: tether_forceb_c(3) 
      real(C_DOUBLE)                                :: wind_g_c(3)       
      character(kind=C_CHAR)                        :: errMsg_c(IntfStrLen)

      real(C_DOUBLE), allocatable                   :: AeroTorq(:), genTorq(:), rtrSpd(:), rtrAcc(:), rtrBladePitch(:), ctrlSettings(:)
      integer(IntKi)                                :: c, i, j, wingOffset
      errStat2 = ErrID_None
      errMsg2  = ''
      
         ! Cast and massage inputs to match DLL datatypes
      t_c             = t
      dcm_g2b_c       = reshape(u%dcm_g2b,(/9/))
      pqr_c           = u%pqr
      acc_norm_c      = u%acc_norm
      Xg_c            = u%Xg
      Vg_c            = u%Vg
      Vb_c            = u%Vb
      Ag_c            = u%Ag
      Ab_c            = u%Ab
      rho_c           = u%rho
      apparent_wind_c = u%apparent_wind
      tether_forceb_c = u%tether_forceb
      wind_g_c        = u%wind_g
      
      
      if (.not. p%useDummy) then
         allocate(AeroTorq(p%numPylons*4), stat = errStat)
         allocate(genTorq(p%numPylons*4), stat = errStat)
         allocate(rtrSpd(p%numPylons*4), stat = errStat)
         allocate(rtrAcc(p%numPylons*4), stat = errStat)
         allocate(rtrBladePitch(p%numPylons*4), stat = errStat)
         allocate(ctrlSettings(p%numFlaps*2+6), stat = errStat)

         c = 1
         wingOffset = 2*p%numPylons
         do j=1,p%numPylons
            do i=1,2
               AeroTorq(c)              = u%SPyAeroTorque(i,j)
               AeroTorq(c + wingOffset) = u%PPyAeroTorque(i,j)
               c = c + 1
            end do
         end do

            print *, " ========================================"
            print *, " KFC_Step - Inputs at time = ", t
            print *, " debug - SPyAeroTorque: ", u%SPyAeroTorque
            print *, " debug - PPyAeroTorque: ", u%PPyAeroTorque
            print *, " debug - AeroTorq     : ", AeroTorq
            print *, " debug - pqr          : ", u%pqr
            print *, " debug - acc_norm     : ", u%acc_norm
            print *, " debug - Xg           : ", u%Xg
            print *, " debug - Vg           : ", u%Vg
            print *, " debug - Vb           : ", u%Vb
            print *, " debug - Ag           : ", u%Ag
            print *, " debug - Ab           : ", u%Ab
            print *, " debug - apparent_wind: ", u%apparent_wind
            print *, " debug - tether_forceb: ", u%tether_forceb
            print *, " debug - wind_g       : ", u%wind_g

            ! Call the DLL (first associate the address from the procedure in the DLL with the subroutine):
         call C_F_PROCPOINTER( p%DLL_Trgt%ProcAddr(2), DLL_KFC_Step_Subroutine) 
         call DLL_KFC_Step_Subroutine ( t_c, dcm_g2b_c, pqr_c, acc_norm_c, Xg_c, Vg_c, Vb_c, Ag_c, Ab_c, rho_c, apparent_wind_c, tether_forceb_c, wind_g_c, AeroTorq, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg_c ) 
         call c_to_fortran_string(errMsg_c, errMsg)

          ! print *, " KFC_Step errStat - ", errStat, " errMsg - ", trim(errMsg)
            print *, " KFC_Step - Outputs "
            print *, " debug - genTorq     : ", genTorq
            print *, " debug - rtrSpd      : ", rtrSpd
            print *, " debug - ctrlSettings: ", ctrlSettings
            print *, " ========================================"

         ! obtain initial outputs from the DLL and set them
         !call MapKFCOutputs( p%numFlaps, p%numPylons, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, y)
            ! This uses the Dummy controller to set the outputs for KiteFAST, the 3 values are rotor speed, rotor acceleration, and blade pitch
         call MapDummyKFCOutputs( p%numFlaps, p%numPylons, u%SPyAeroTorque, u%PPyAeroTorque, 120.0_ReKi, 0.0_ReKi, 0.0_ReKi, y)
         
      else
            ! This uses the Dummy controller to set the outputs for KiteFAST, the 3 values are rotor speed, rotor acceleration, and blade pitch
         call MapDummyKFCOutputs( p%numFlaps, p%numPylons, u%SPyAeroTorque, u%PPyAeroTorque, 120.0_ReKi, 0.0_ReKi, 0.0_ReKi, y)
         
      end if
      
   end subroutine KFC_Step
   
   subroutine c_to_fortran_string(input, output)
      character(kind=C_CHAR), intent(in) :: input(IntfStrLen)
      character(*), intent(out) :: output
      character(1024) :: temp_string
      temp_string = transfer(input(1:1024), output)
      call RemoveNullChar(temp_string)
      output = trim(temp_string)
   end subroutine

end module KiteFastController
