!**********************************************************************************************************************************
!> ## KFC
!! The KiteFastController  module implements a controller for the KiteFAST code. 
!! KiteFastController_Types will be auto-generated by the FAST registry program, based on the variables specified in the
!! KiteFastController_Registry.txt file.
!!
! ..................................................................................................................................
!! ## LICENSING 
!! Copyright (C) 2020 Makani and RRD Engineering, LLC
!!
!!    This file is part of KiteFAST.
!!
!! Licensed under the Apache License, Version 2.0 (the "License");
!! you may not use this file except in compliance with the License.
!! You may obtain a copy of the License at
!!
!!     http://www.apache.org/licenses/LICENSE-2.0
!!
!! Unless required by applicable law or agreed to in writing, software
!! distributed under the License is distributed on an "AS IS" BASIS,
!! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!! See the License for the specific language governing permissions and
!! limitations under the License.
!**********************************************************************************************************************************
module KiteFastController

   use KiteFastController_Types
   use NWTC_Library
   use KiteFastController_IO  !RRD
   use, intrinsic :: ISO_C_Binding
   
   implicit none
   private
   
   integer,        parameter    :: IntfStrLen  = 1025       ! length of strings through the C interface
   type(ProgDesc), parameter    :: KFC_Ver = ProgDesc( 'KiteFastController', '', '' )
   
   !Default values
   CHARACTER(*),      parameter    :: DLL_FileName_Default="~/sandbox/build/modules/kitefast-controller/libkitefastcontroller_controller.so"
   !integer                      :: interval = 0.01_DbKi          ! This is the Default dt for the controller, but it can be changed by input file

      !> Definition of the DLL Interface for the KiteFast Controller
      !! 
   abstract interface
      subroutine KFC_DLL_Init_PROC ( dt, numFlaps, numPylons, rtrIrot, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg )  BIND(C)
         use, intrinsic :: ISO_C_Binding
         real(C_DOUBLE), value,  intent(in   ) :: dt                  !< required simulation time step
         integer(C_INT), value,  intent(in   ) :: numFlaps            !< number of flaps per wing in the Kite model
         integer(C_INT), value,  intent(in   ) :: numPylons           !< number of pylons per wing in the Kite model
         real(C_DOUBLE),         intent(in   ) :: rtrIrot(*)          !< The rotor rotational inertias (m^3), follows ordering for genTorq. !RRD Why m^3????
         real(C_DOUBLE),         intent(inout) :: genTorq(*)          !< The initial generator torques, specified as Top Rotor then Bottom Rotor for inboard Starboard pylon, 
                                                                      !<   then repeat moving outboard.  Then repeat for port side, starting inboard and moving outboard.
         real(C_DOUBLE),         intent(inout) :: rtrSpd(*)           !< The initial rotor speeds (rad/s), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: rtrAcc(*)           !< The initial rotor accelerations (rad/s^2), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: rtrBladePitch(*)    !< The initial rotor-collective blade pitch angles (rad), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: ctrlSettings(*)     !< The initial control surfaces angles(rad), Starts with starboard wing flaps (numFlaps of them), then port wing flaps, 
                                                                      !<   then 2 rudder values, then 2 starboard elevators, then 2 port elevators.
         integer(C_INT),         intent(  out) :: errStat             !< error status code (uses NWTC_Library error codes)
         character(kind=C_CHAR), intent(inout) :: errMsg          (*) !< Error Message from DLL to simulation code        
      end subroutine KFC_DLL_Init_PROC   
   end interface   

   abstract interface
      subroutine KFC_DLL_Step_PROC ( t_c, dcm_g2b_c, pqr_c, acc_norm_c, Xg_c, Vg_c, Vb_c, Ag_c, Ab_c, rho_c, apparent_wind_c, &
         tether_forceb_c, wind_g_c, aeroTorq, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg )  BIND(C)
         use, intrinsic :: ISO_C_Binding
         real(C_DOUBLE), value,  intent(in   ) :: t_c                 !<simulation time (s)
         real(C_DOUBLE),         intent(in   ) :: dcm_g2b_c(9)
         real(C_DOUBLE),         intent(in   ) :: pqr_c(3)          
         real(C_DOUBLE),         intent(in   ) :: acc_norm_c    
         real(C_DOUBLE),         intent(in   ) :: Xg_c(3)           
         real(C_DOUBLE),         intent(in   ) :: Vg_c(3)           
         real(C_DOUBLE),         intent(in   ) :: Vb_c(3)           
         real(C_DOUBLE),         intent(in   ) :: Ag_c(3)           
         real(C_DOUBLE),         intent(in   ) :: Ab_c(3)           
         real(C_DOUBLE),         intent(in   ) :: rho_c          
         real(C_DOUBLE),         intent(in   ) :: apparent_wind_c(3)
         real(C_DOUBLE),         intent(in   ) :: tether_forceb_c(3) 
         real(C_DOUBLE),         intent(in   ) :: wind_g_c(3) 
         real(C_DOUBLE),         intent(in   ) :: aeroTorq(*)           !< The aerodynamic torques.  See genTorq, below for ordering.
         real(C_DOUBLE),         intent(inout) :: genTorq(*)            !< The generator torques, specified as Top Rotor then Bottom Rotor for inboard Starboard pylon, 
                                                                        !<   then repeat moving outboard.  Then repeat for port side, starting inboard and moving outboard.
         real(C_DOUBLE),         intent(inout) :: rtrSpd(*)             !< The rotor speeds (rad/s), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: rtrAcc(*)             !< The rotor accelerations (rad/s^2), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: rtrBladePitch(*)      !< The rotor-collective blade pitch angles (rad), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: ctrlSettings(*)       !< The control surfaces angles(rad), Starts with starboard wing flaps (numFlaps of them), then port wing flaps, 
                                                                        !<   then 2 rudder values, then 2 starboard elevators, then 2 port elevators.
         integer(C_INT),         intent(inout) :: errStat               !< error status code (uses NWTC_Library error codes)
         character(kind=C_CHAR), intent(inout) :: errMsg(1025)          !< Error Message from DLL to simulation code        
      end subroutine KFC_DLL_Step_PROC                                  
   end interface   
 
   abstract interface
      subroutine KFC_DLL_END_PROC ( errStat, errMsg )  BIND(C)
         use, intrinsic :: ISO_C_Binding
         integer(C_INT),         intent(  out) :: errStat             !< error status code (uses NWTC_Library error codes)
         character(kind=C_CHAR), intent(inout) :: errMsg          (*) !< Error Message from DLL to simulation code        
      end subroutine KFC_DLL_END_PROC   
   end interface   

   public :: KFC_Init                     ! Initialization routine
   public :: KFC_End                      ! Ending routine (includes clean up)
   public :: KFC_Step                     ! Routine for computing outputs and internally updating states
  
   contains   
   
   
!   subroutine MapKFCOutputs( numFlaps, numPylons, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, y)
!   subroutine KFC_MapOutputs(p, u,  y, m, o,  rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg)
   subroutine KFC_MapOutputs(p, u,  y, m, o,   errStat, errMsg)
      type(KFC_ParameterType),       intent(in   )  :: p           !< KFC Parameters
      type(KFC_InputType),           intent(in   )  :: u           !< KFC inputs
      type(KFC_OutputType),          intent(inout)  :: y           !< KFC system outputs 
      type(KFC_MiscVarType),         intent(inout)  :: m           !< KFC MiscVars for the module
      type(KFC_OtherStateType),      intent(in   )  :: o           !< KFC Other states, containing C-SIM output                            
      integer(IntKi),                intent(  out)  :: errStat     !< Error status of the operation
      character(*),                  intent(  out)  :: errMsg      !< Error message if errStat /= ErrID_None
      
      character(*), parameter     :: RoutineName = 'KFC_MapOutputs'
     
!      integer(IntKi),       intent(in   ) :: numFlaps
!      integer(IntKi),       intent(in   ) :: numPylons
     ! real(C_DOUBLE),       intent(in   ) :: genTorq(:)
      !real(C_DOUBLE),       intent(in   ) :: rtrSpd(:)
      !!real(C_DOUBLE),       intent(in   ) :: rtrAcc(:)
      !real(C_DOUBLE),       intent(in   ) :: rtrBladePitch(:)
      !real(C_DOUBLE),       intent(in   ) :: ctrlSettings(:)
      
      
      integer(IntKi)                :: wingOffset, i, j, c, cp,cs

     errStat = ErrID_None
     errMsg  = ''

         ! Set outputs to zero for now
      ! c = 1
      ! wingOffset = 2*p%numPylons
      ! do j=1,p%numPylons
      !    do i=1,2
      !       !print *, ">>>>>>>> RRD_debug In",RoutineName,"o%genTorq(c)=",o%genTorq(c)," <<<<<<<<<<<<<<<<<<<<< \n" 
      !       y%SPyGenTorque(i,j) = o%genTorq(c)
      !       y%SPyRtrSpd(i,j)    = o%rtrSpd(c)
      !       y%SPyRtrAcc(i,j)    = o%rtrAcc(c)
      !       y%SPyBldPitch(i,j)  = o%rtrBladePitch(c)

      !       y%PPyRtrAcc(i,j)    = o%rtrAcc(c + wingOffset)
      !       y%PPyRtrSpd(i,j)    = o%rtrSpd(c + wingOffset)
      !       y%PPyGenTorque(i,j) = o%genTorq(c + wingOffset)
      !       y%PPyBldPitch(i,j)  = o%rtrBladePitch(c + wingOffset)
      !       !print *, ">>>>>>>> RRD_debug In ",RoutineName," o%genTorq(c+ wingOffset)=",o%genTorq(c+ wingOffset),"y%PPyGenTorque(i,j)=",y%PPyGenTorque(i,j), " <<<<<<<<<<<<<<<<<<<<< \n" 
      !       c = c + 1
            
      !    end do
      ! end do

      !RRD:  mapping redone for motors too. The location order is the CSIM one, and they get assigned to Port/Starboard here
      do j=1,p%numPylons
         do i=1,2
            cp=(i-1)*(p%numPylons+j) + (2-i)*(p%nRotors+1-j-p%numPylons)
            cs=(i-1)*(p%numPylons-j+1) + (2-i)*(p%nRotors-p%numPylons+j)
            
            y%PPyGenTorque(i,j) = o%genTorq(cp)
            y%PPyRtrAcc(i,j)    = o%rtrAcc(cp)
            y%PPyRtrSpd(i,j)    = o%rtrSpd(cp)            
            y%PPyBldPitch(i,j)  = o%rtrBladePitch(cp)

            y%SPyGenTorque(i,j) = o%genTorq(cs)
            y%SPyRtrAcc(i,j)    = o%rtrAcc(cs)
            y%SPyRtrSpd(i,j)    = o%rtrSpd(cs)       
            y%SPyBldPitch(i,j)  = o%rtrBladePitch(cs)

         end do   
      end do
      !RRD: To me the following looks all wrong, so I am redoing the mapping below:
      !y%SFlp         = o%ctrlSettings(1:p%numFlaps)
      !y%PFlp         = o%ctrlSettings(p%numFlaps+1:2*p%numFlaps)
      !y%Rudr         = o%ctrlSettings(2*p%numFlaps+1:2*p%numFlaps+2)
      !y%SElv         = o%ctrlSettings(2*p%numFlaps+3:2*p%numFlaps+4)
      !y%PElv         = o%ctrlSettings(2*p%numFlaps+5:2*p%numFlaps+6)

      y%PFlp         = o%ctrlSettings(1:p%numFlaps)
      y%SFlp         = o%ctrlSettings(p%numFlaps+1:2*p%numFlaps)
      
      y%PElv         = o%ctrlSettings(2*p%numFlaps+1)
      y%SElv         = o%ctrlSettings(2*p%numFlaps+1)
      
      y%Rudr         = o%ctrlSettings(2*p%numFlaps+2)



      !Set output file data ---RRD
    do i = 1, p%NRotOuts
               
         if (errStat >= AbortErrLev) then
            call SetErrStat( ErrID_Fatal, 'The Generators', errStat, errMsg, RoutineName )
            return
         end if
      
      m%AllOuts( GenTq(i) )  = o%genTorq(i)
      m%AllOuts( RotSpd(i) ) = o%rtrSpd(i)
      m%AllOuts( RotAtq(i) ) = o%AeroTorq(i)      
    end do
    
    do i = 1, p%NFlpOuts
 
      if (errStat >= AbortErrLev) then
         call SetErrStat( ErrID_Fatal, 'The Flaps', errStat, errMsg, RoutineName )
         return
      end if
 
      m%AllOuts( FlpDef(i) ) = o%ctrlSettings(i)

    end do
   !Assign Allouts-DCMG2B here, but we should check whether or not it is requested
    !!print *, ">>>>>>>> RRD_Debug: In ",routineName," befdore DCMG2B to ALLOUTS =p%NumOuts", p%NumOuts," <<<<<<<<<<<<<<<<<<<<< \n"  
    m%AllOuts( DCMG2Bc1:DCMG2Bc9 ) = RESHAPE(u%dcm_g2b,(/9/))    
    if (errStat >= AbortErrLev) then
          call SetErrStat( ErrID_Fatal, 'The DCMg2bC', errStat, errMsg, RoutineName )
          return
    end if
  
   !Assign Allouts-TethFb here, but we should check whether or not it is requested
    
    m%AllOuts( TethFxb:TethFzb ) = u%tether_forceb
    if (errStat >= AbortErrLev) then
          call SetErrStat( ErrID_Fatal, 'The Tether_Forceb', errStat, errMsg, RoutineName )
          return
    end if
    !!print *, ">>>>>>>> RRD_Debug: In ",routineName," after DCMG2B to ALLOUTS=", DCMG2Bc((i-1)*3 +j)," <<<<<<<<<<<<<<<<<<<<< \n"  
   end subroutine KFC_MapOutputs 
   
   subroutine KFC_End(p, errStat, errMsg)

      type(KFC_ParameterType),        intent(inout)  :: p               !< Parameters
      integer(IntKi),                 intent(  out)  :: errStat         !< Error status of the operation
      character(*),                   intent(  out)  :: errMsg          !< Error message if ErrStat /= ErrID_None

         ! local variables
      character(*), parameter                        :: routineName = 'KFC_End'
      integer(IntKi)                                 :: errStat2       ! The error status code
      character(ErrMsgLen)                           :: errMsg2        ! The error message, if an error occurred
      procedure(KFC_DLL_END_PROC),pointer            :: DLL_KFC_End_Subroutine       ! The address of the controller cc_end procedure in the DLL
      character(kind=C_CHAR)                         :: errMsg_c(IntfStrLen)
      errStat = ErrID_None
      errMsg= ''
      
      IF (p%KFCmode .EQ. 1) THEN

        ! Call the DLL's end subroutine:
         Call C_F_PROCPOINTER( p%DLL_Trgt%ProcAddr(3), DLL_KFC_End_Subroutine) 
         Call DLL_KFC_End_Subroutine ( errStat, errMsg_c ) 
         Call c_to_fortran_string(errMsg_c, errMsg)

      ENDIF   

      CALL KFC_CloseOutput ( p, ErrStat, ErrMsg )

      print *, " KFC_End errStat - ", errStat, " errMsg - ", trim(errMsg)

         ! TODO: Check errors
      
            ! Free the library
         call FreeDynamicLib( p%DLL_Trgt, errStat2, errMsg2 )  
            call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
     
   end subroutine KFC_End

   subroutine KFC_Init(InitInp, u, p, y, interval, m, o, InitOut, errStat, errMsg )
      
      type(KFC_InitInputType),      intent(inout   )  :: InitInp     !< Input data for initialization routine >>>RRD: made this inout instead of in
      type(KFC_InitOutputType),     intent(inout   )  :: InitOut     !< Output data for initialization routine >>>RRD added
      type(KFC_MiscVarType),        intent(  out)  :: m           !< MiscVars for the module >>>RRD added
      type(KFC_InputType),          intent(inout)  :: u           !< An initial guess for the input
      type(KFC_ParameterType),      intent(  out)  :: p           !< Parameters
      type(KFC_OutputType),         intent(  out)  :: y           !< Initial system outputs 
      type(KFC_OtherStateType),      intent(out   )  :: o           !< KFC Other states, containing C-SIM output                            

      real(DbKi),                   intent(inout)  :: interval    !< Coupling interval in seconds: 
                                                                  !<   Input is the timestep size requested by caller, returned is the Controller's required timestep
      integer(IntKi),               intent(  out)  :: errStat     !< Error status of the operation
      character(*),                 intent(  out)  :: errMsg      !< Error message if errStat /= ErrID_None
 
         ! local variables
      character(*), parameter                 :: routineName = 'KFC_Init'
      integer(IntKi)                          :: errStat2                     ! The error status code
      character(ErrMsgLen)                    :: errMsg2                      ! The error message, if an error occurred
      procedure(KFC_DLL_Init_PROC),pointer    :: DLL_KFC_Init_Subroutine       ! The address of the controller cc_init procedure in the DLL
      
      character(kind=C_CHAR)                  :: errMsg_c(IntfStrLen)
      !!real(C_DOUBLE), allocatable             :: rtrIrot(:), genTorq(:), rtrSpd(:), rtrAcc(:), rtrBladePitch(:), ctrlSettings(:)  !!RRD I replaced this with OtherStates in Registry
      real(C_DOUBLE)                          :: dt_c
      integer(IntKi)                          :: wingOffset, i, j, c
      
          
      errStat2 = ErrID_None
      errMsg2  = ''
   
      call DispNVD( KFC_Ver )  ! Display the version of this interface
      
         ! Check that key Kite model components match the requirements of this controller interface.
      !=============================================================================================
      ! NOTE: GJH: Perhaps a better design is to let the actual controller (shared object) determine if numFlaps and numPylons and interval are acceptable
      !
      !if (InitInp%numFlaps /= 3) call SetErrStat( ErrID_Fatal, 'The current KiteFAST controller interface requires numFlaps = 3', errStat, errMsg, routineName )
      !if (InitInp%numPylons /= 2) call SetErrStat( ErrID_Fatal, 'The current KiteFAST controller interface requires numPylons = 2', errStat, errMsg, routineName )
      !if (.not. EqualRealNos(interval, 0.01_DbKi)) call SetErrStat( ErrID_Fatal, 'The current KiteFAST controller interface requires DT = 0.01 seconds', errStat, errMsg, routineName )
      !   if (errStat >= AbortErrLev ) return
      !=============================================================================================  
      
      interval    = 0.01_DbKi          ! This is the Default dt for the controller, but it can be changed by input file

      
               ! Set the module's parameters
      p%numFlaps  = InitInp%numFlaps
      p%numPylons = InitInp%numPylons

      p%useDummy  = InitInp%useDummy
      p%nCtrlSettings = 2*p%numFlaps+2 ! "Number of Flap Deflections " -
      p%nRotors       = 4*p%numPylons  ! "Number of Rotors[ (rad/s^2)" -
      p%KFCmode = InitInp%KFCmode

         ! allocate the inputs and outputs
      call AllocAry( u%SPyAeroTorque, 2, p%numPylons, 'u%SPyAeroTorque', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( u%PPyAeroTorque, 2, p%numPylons, 'u%PPyAeroTorque', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%SPyGenTorque,  2, p%numPylons, 'y%SPyGenTorque',  errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PPyGenTorque,  2, p%numPylons, 'y%PPyGenTorque',  errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )   
      call AllocAry( y%SPyRtrSpd,     2, p%numPylons, 'y%SPyRtrSpd',     errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PPyRtrSpd,     2, p%numPylons, 'y%PPyRtrSpd',     errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )  
       call AllocAry( y%SPyRtrAcc,     2, p%numPylons, 'y%SPyRtrAcc',     errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PPyRtrAcc,     2, p%numPylons, 'y%PPyRtrAcc',     errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )  
      call AllocAry( y%SPyBldPitch,   2, p%numPylons, 'y%SPyBldPitch',   errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PPyBldPitch,   2, p%numPylons, 'y%PPyBldPitch',   errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )   
      call AllocAry( y%SFlp, p%numFlaps, 'y%SFlp', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PFlp, p%numFlaps, 'y%PFlp', errStat2, errMsg2 )   
      !RRD added the following OtherStates
      call AllocAry( o%ctrlsettings,p%nCtrlSettings, 'o%ctrlsettings', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( o%rtrSpd,p%nRotors, 'o%rtrSpd', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( o%rtrAcc,p%nRotors, 'o%rtrAcc', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( o%genTorq,p%nRotors, 'o%genTorq', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( o%rtrBladePitch,p%nRotors, 'o%rtrBladePitch', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( o%rtrIrot,p%nRotors, 'o%rtrIrot', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( o%AeroTorq,p%nRotors, 'o%AeroTorque', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      
      if (errStat >= AbortErrLev ) return

      !>>>>>>>>>>>>>>>>>>>>>>>>>RRD Get ICs in case and then call Controller_Init<<<<<<<<<<<<<<<<<<<<<<<<<<<
      
      !InitInp%Filename='./RRD_ctrl_input.dat'  !RRD:hardwire for now, it will be read elsewhere in the future from InitInp%Filename

      
      ! Read Input file, otherwise the caller must have fully populated the Initialization inputs
         if ( trim(InitInp%InputFileName) /= '' ) then
            call ReadKFCFile(InitInp, interval, p, errStat, errMsg)
            if ( errStat > ErrID_None ) return
      !      print *, ">>>>>>>> RRD_Debug: In ",routineName,"InitInp%Filename is ",InitInp%Filename," <<<<<<<<<<<<<<<<<<<<< \n"  
         endif
      
         ! Validate the input file data and issue errors as needed
         call ValidateInitData(InitInp,p%KFCmode, errStat, errMsg)
         if ( errStat >= AbortErrLev ) return
      
      ! Update dt based on the input file
         interval        = InitInp%InpFileData%DTctrl

   
         ! Are we simply using a dummy controller?  If so, we will skip trying to call into a DLL/SO      
         
      SELECT CASE (p%KFCmode)

         CASE (0) ! Dummy Controller
               ! Set outputs to zero except for RtrSpd which is set to be constant for the dummy controller
            ! TODO: Determine what would be a realistic dummy set of speed and the correct signs for each rotor
            o%genTorq=0.0_ReKi
            o%genTorq(3)=110.0_ReKi
            o%rtrSpd=100
            o%rtrSpd(1)=-100
            o%rtrSpd(3)=-100
            
            if ( p%numPylons > 1 ) then
               o%rtrSpd(5)=-100
               o%rtrSpd(7)=-100
               ! y%SPyRtrSpd(1,2) = 100.0  ! starboard top rotor, outer pylons 
               !y%SPyRtrSpd(2,2) = -100.0  ! starboard bottom rotor, outer pylons
               !y%PPyRtrSpd(1,2) = 100.0  ! port top rotor, outer pylon
               !y%PPyRtrSpd(2,2) = -100.0  ! port bottom rotor, outer pylon
            end if
            o%rtrAcc=10.0_ReKi  ! rad/s^2
            o%rtrAcc(3)=12.0_ReKi  ! rad/s^2
            !y%SPyRtrAcc    =   10.0_ReKi  ! rad/s^2
            !y%PPyRtrAcc    =   12.0_ReKi  ! rad/s^2
            o%rtrBladePitch=2.0_ReKi  ! deg ???
            o%rtrBladePitch(3)=1.0_ReKi  ! deg ???
            
            !y%SPyBldPitch  = 0.0_ReKi
   
            !y%PPyBldPitch  = 0.0_ReKi
               ! All flag commands are constant for the dummy controller
             !RRD I introduced o% for all otherstates, i.e. those given by external controller
            o%ctrlSettings(1:p%numFlaps)=0.1_ReKi !starboard flap
            o%ctrlSettings(p%numFlaps+1:2*p%numFlaps)=-0.3_ReKi !port flap
            o%ctrlSettings(2*p%numFlaps+1:p%nCtrlSettings)=0.2_ReKi !rudder
            o%ctrlSettings(2*p%numFlaps+3:2*p%numFlaps+4)=0.4_ReKi ! starboard elevator
            o%ctrlSettings(2*p%numFlaps+5:2*p%numFlaps+6)=0.5_ReKi ! port elevator
           
         
         CASE(2)  ! External Data File
            ! Now, assess whether we need to start reading from dummyCtrlFile (which is not the dummy controller hardcoded here)
            IF  (InitInp%InpFileData%DmyCtl_FName .NE. " ") THEN
               ! Open and initialize the CTRL DATA FILE
                p%DmyCtl_FName = InitInp%InpFileData%DmyCtl_FName
                Call KFC_OpenDmyFile( o, p, ErrStat, ErrMsg )
                if (ErrStat >= AbortErrLev) return
            ELSE
               ErrMsg= 'The DmyCtl_FName is blank and must be set when KFCmode=2'
               ErrStat =AbortErrLev
            ENDIF
                  
         CASE DEFAULT !=1, regular controller
         
            ! Set up the actual c-controller library
               call RemoveNullChar(InitInp%InpFileData%DLL_FileName)
      
            ! Define and load the DLL:
               p%DLL_Trgt%FileName = InitInp%InpFileData%DLL_FileName

               p%DLL_Trgt%ProcName = "" ! initialize all procedures to empty so we try to load only one
               p%DLL_Trgt%ProcName(1) = 'kfc_dll_init'
               p%DLL_Trgt%ProcName(2) = 'kfc_dll_step'
               p%DLL_Trgt%ProcName(3) = 'kfc_dll_end'
            
               call LoadDynamicLib ( p%DLL_Trgt, errStat2, errMsg2 )
                  call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
               if (errStat >= AbortErrLev ) return

               ! Now that the library is loaded, call the controller's kfc_dll_init routine

                  ! Call the DLL (first associate the address from the procedure in the DLL with the subroutine):
               call C_F_PROCPOINTER( p%DLL_Trgt%ProcAddr(1), DLL_KFC_Init_Subroutine) 
            
               !RRD I replaced the following allocs with OtherStates above
               ! allocate(rtrIrot(p%numPylons*4), stat = errStat)
               ! allocate(genTorq(p%numPylons*4), stat = errStat)
               ! allocate(rtrSpd(p%numPylons*4), stat = errStat)
               ! allocate(rtrAcc(p%numPylons*4), stat = errStat)
               ! allocate(rtrBladePitch(p%numPylons*4), stat = errStat)
               ! allocate(ctrlSettings(p%numFlaps*2+6), stat = errStat)
               
               dt_c = real(interval, C_DOUBLE)  ! RRD replaced 0.01 with interval :This is hardcoded for the Makani Controller
               
               c = 1
               wingOffset = 2*p%numPylons
               do j=1,p%numPylons
                  do i=1,2
                     o%rtrIrot(c)              = InitInp%SPyRtrIrot(i,j)
                     o%rtrIrot(c + wingOffset) = InitInp%PPyRtrIrot(i,j)
                     c = c + 1
                  end do
               end do

               o%genTorq        = InitInp%InpFileData%genTorq
               o%rtrSpd         = InitInp%InpFileData%rtrSpd
               o%rtrAcc         = InitInp%InpFileData%rtrAcc
               o%rtrBladePitch  = InitInp%InpFileData%rtrBladePitch
               o%ctrlSettings   = InitInp%InpFileData%ctrlSettings
               
               !print *, ">>>>>>>> RRD_Debug: In ",routineName,"- dt_c, o%genTorq before DLL_INIT=",dt_c, o%genTorq, "<<<<<<<<<<<<<<<<"  
               !call DLL_KFC_Init_Subroutine ( dt_c, p%numFlaps*2+2, p%numPylons, rtrIrot, o%genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg_c ) 
               call DLL_KFC_Init_Subroutine ( dt_c, p%numFlaps*2+2, p%numPylons, o%rtrIrot, o%genTorq, o%rtrSpd, o%rtrAcc, o%rtrBladePitch, o%ctrlSettings, errStat, errMsg_c )  !RRD
               !print *, ">>>>>>>> RRD_Debug: In ",routineName,"- o%genTorq after DLL_INIT=",o%genTorq, "<<<<<<<<<<<<<<<<"  
               
               call c_to_fortran_string(errMsg_c, errMsg)
               ! print *, " KFC_Init errStat - ", errStat, " errMsg - ", trim(errMsg)
               ! TODO: Check errors
               !print *, " debug marker - pre errStat >= Abort"
               if (errStat >= AbortErrLev ) return
               
               !print *, " debug marker - post errStat >= Abort"
               !print *, " debug - o%genTorq     : ", o%genTorq
               ! print *, " debug - rtrSpd      : ", rtrSpd
               !print *, " debug - o%ctrlSettings: ", o%ctrlSettings
               
               ! obtain initial outputs from the DLL and set them
               !!call KFC_MapOutputs( p%numFlaps, p%numPylons, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, y)
            ! call KFC_MapOutputs(p, u,  y, m, o,  rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg)
      END SELECT

      !----------------------------------
      ! Create the file-related output data
      !----------------------------------
      allocate( m%AllOuts(0:MaxOutPts), STAT=errStat2 ) ! allocate starting at zero to account for invalid output channels
      IF ( ErrStat /= 0 )  THEN
         errStat = ErrID_Fatal
         errMsg  = ' Error allocating memory for the AllOuts array.'
         RETURN
      ENDIF   
      m%AllOuts   = 0.0_ReKi
      p%OutSwtch  = InitInp%InpFileData%OutSwtch
      p%NumOuts   = InitInp%InpFileData%NumOuts !this could be numouts instead
      p%NFlpOuts  = InitInp%InpFileData%NFlpOuts
      p%FlpOuts   = InitInp%InpFileData%FlpOuts
      p%OutFmt    = InitInp%InpFileData%OutFmt
      p%NRotOuts  = InitInp%InpFileData%NRotOuts
      p%RotOuts   = InitInp%InpFileData%RotOuts
      

      !print *, ">>>>>RRD_debug: In ",RoutineName," p%NFlpOuts, p%NumOuts=",p%NFlpOuts, p%NumOuts
                  !!call KFC_MapOutputs( p%numFlaps, p%numPylons, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, y)
      call KFC_MapOutputs(p, u,  y, m, o,  errStat, errMsg)
      !call KFC_MapOutputs(p, u,  y, m, o,  rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg)

            ! Set parameters for output channels:
      CALL KFC_SetOutParam(InitInp%InpFileData%OutList, p, errStat, errMsg ) ! requires: p%NumOuts, p%NRotOuts; sets: p%OutParam.
         IF (ErrStat >= AbortErrLev) RETURN
   
      IF ( InitInp%InpFileData%TabDelim ) THEN
         p%Delim = TAB
      ELSE
         p%Delim = ' '
      END IF
   
      if ( p%OutSwtch == 2 .or. p%OutSwtch == 3 ) then
         CALL AllocAry( InitOut%WriteOutputHdr, p%NumOuts, 'WriteOutputHdr', ErrStat, ErrMsg )
            IF (ErrStat >= AbortErrLev) RETURN
         CALL AllocAry( InitOut%WriteOutputUnt, p%NumOuts, 'WriteOutputUnt', ErrStat, ErrMsg )
         
            IF (ErrStat >= AbortErrLev) RETURN
         
         do i=1,p%NumOuts
            InitOut%WriteOutputHdr(i) = p%OutParam(i)%Name
            InitOut%WriteOutputUnt(i) = p%OutParam(i)%Units
         end do
      end if

      ! Open and initialize the output file/data
      p%OutFileRoot = InitInp%OutFileRoot
      
      if (p%OutSwtch /= 2) then   
         call KFC_OpenOutput( KFC_Ver, p%OutFileRoot,  p, InitOut, ErrStat, ErrMsg )
            if (ErrStat >= AbortErrLev) return
      end if
      
      call AllocAry( y%WriteOutput, p%NumOuts, 'y%WriteOutput', ErrStat, ErrMsg )   
         if (ErrStat >= AbortErrLev) return
      y%WriteOutput = 0.0_ReKi
      
   !...............................................................................................................................
   ! Place the selected output channels into the WriteOutput(:) array with the proper sign:
   !...............................................................................................................................

      dO i = 1,p%NumOuts  ! Loop through all selected output channels
         y%WriteOutput(i) = p%OutParam(i)%SignM * m%AllOuts( p%OutParam(i)%Indx )
      end do             ! i - All selected output channels
   

      if (p%OutSwtch /= 2) call KFC_WrOutputLine(0.0_DbKi, p, y%WriteOutput, errStat, errMsg)

      !!print *, ">>>>>>>> RRD_Debug: At the end of ",routineName,"Passed <<<<<<<<<<<<<<<<<<<<< \n"  

   end subroutine KFC_Init

   subroutine KFC_Step(t, u, p, y, m, o, errStat, errMsg )
      real(DbKi),                    intent(in   )  :: t           !< Current simulation time in seconds
      type(KFC_InputType),           intent(in   )  :: u           !< Inputs at Time t
      type(KFC_ParameterType),       intent(in   )  :: p           !< Parameters
      type(KFC_OutputType),          intent(inout)  :: y           !< Outputs computed at t (Input only so that mesh con-
                                                                   !!   nectivity information does not have to be recalculated)
      type(KFC_MiscVarType),         intent(inout)  :: m           !< KFC MiscVars for the module
      type(KFC_OtherStateType),      intent(inout)  :: o           !< KFC Other states, containing C-SIM output; out just for dummy controller                            


      integer(IntKi),                intent(  out)  :: errStat     !< Error status of the operation
      character(*),                  intent(  out)  :: errMsg      !< Error message if ErrStat /= ErrID_None
   
      character(*), parameter                       :: routineName = 'KFC_Step'
      integer(IntKi)                                :: errStat2       ! The error status code
      character(ErrMsgLen)                          :: errMsg2        ! The error message, if an error occurred     
      procedure(KFC_DLL_Step_PROC),pointer          :: DLL_KFC_Step_Subroutine              ! The address of the supercontroller sc_calcoutputs procedure in the DLL
      real(C_DOUBLE)                                :: t_c
      real(C_DOUBLE)                                :: dcm_g2b_c(9) 
      real(C_DOUBLE)                                :: pqr_c(3)
      real(C_DOUBLE)                                :: acc_norm_c
      real(C_DOUBLE)                                :: Xg_c(3)
      real(C_DOUBLE)                                :: Vg_c(3)
      real(C_DOUBLE)                                :: Vb_c(3)
      real(C_DOUBLE)                                :: Ag_c(3)
      real(C_DOUBLE)                                :: Ab_c(3)
      real(C_DOUBLE)                                :: rho_c          
      real(C_DOUBLE)                                :: apparent_wind_c(3)
      real(C_DOUBLE)                                :: tether_forceb_c(3) 
      real(C_DOUBLE)                                :: wind_g_c(3)       
      character(kind=C_CHAR)                        :: errMsg_c(IntfStrLen)

      !!real(C_DOUBLE), allocatable                   :: AeroTorq(:) , genTorq(:), rtrSpd(:), rtrAcc(:), rtrBladePitch(:), ctrlSettings(:)  !!RRD I replaced this with OtherStates in Registry
      integer(IntKi)                                :: c, i, j, wingOffset, cp, cs
      errStat2 = ErrID_None
      errMsg2  = ''
      
         ! Cast and massage inputs to match DLL datatypes
      t_c             = t
      dcm_g2b_c       = reshape(u%dcm_g2b,(/9/))
      pqr_c           = u%pqr
      acc_norm_c      = u%acc_norm
      Xg_c            = u%Xg
      Vg_c            = u%Vg
      Vb_c            = u%Vb
      Ag_c            = u%Ag
      Ab_c            = u%Ab
      rho_c           = u%rho
      apparent_wind_c = u%apparent_wind
      tether_forceb_c = u%tether_forceb
      wind_g_c        = u%wind_g
      
      !!print *, ">>>>>>>> RRD_Debug: At the start of ",routineName," t=,",t,"  <<<<<<<<<<<<<<<<<<<<< \n"  
      SELECT CASE (p%KFCmode)

      CASE (0) ! Dummy Controller
            ! TODO: Determine what would be a realistic dummy set of speed and the correct signs for each rotor
            ! NOTE: Speed should match the settings used in the Init routine.
         o%rtrSpd=(/-100.0,100.0,200.0,210.0,-300.0,310.0,400.0,-410.0/)
         
            ! Zero rotor acceleration
         o%rtrSpd=(/-10.0,10.0,11.0,-12.0,-30.0,31.0,22.0,-22.0/)
         !y%SPyRtrAcc(1,:) = 10.0_ReKi ! starboard top rotor, all pylons 
         !y%SPyRtrAcc(2,:) = 11.0_ReKi ! starboard bottom rotor, all pylons
         !y%PPyRtrAcc(1,:) = 12.0_ReKi ! port top rotor, all pylons
         !y%PPyRtrAcc(2,:) = 13.0_ReKi ! port bottom rotor, all pylons
         
            ! Currently blade pitch is not being set by controller and was initialized to 0.0
         o%rtrBladePitch= 0.0_ReKi
         !y%SPyBldPitch  = 0.0_ReKi
         !y%PPyBldPitch  = 0.0_ReKi
         
         ! Set GenTorque = -AeroTorque
         o%genTorq=(/-123.0,123.0,111.0,-112.0,-320.0,131.0,122.0,-121.0/)
         !y%SPyGenTorque = -u%SPyAeroTorque  ! starboard rotors
         !y%PPyGenTorque = -u%PPyAeroTorque  ! port rotors
        
            ! All flag commands are constant for the dummy controller
         o%ctrlSettings(1:p%numFlaps)=-0.1_ReKi !port flaps
         o%ctrlSettings(p%numFlaps+1:2*p%numFlaps)=+0.3_ReKi !starboard flaps
         o%ctrlSettings(2*p%numFlaps+1)=-0.01_ReKi !elevator
         o%ctrlSettings(p%nCtrlSettings)=-0.4_ReKi ! rudder
   
      CASE (2)   
         !Override controller output if user requested to read a data file
         !print *, ">>>>>>RRD_Debug:  Before Step-KFC_RdCtrlDataLine t=", t
         CALL KFC_RdCtrlDataLine( o, p, ErrStat, ErrMsg)
         IF ( ErrStat >= AbortErrLev ) RETURN

      CASE DEFAULT !=1, regular controller
                  
         !RRD replaced the following with otherstates
         !allocate(AeroTorq(p%numPylons*4), stat = errStat)
         !allocate(genTorq(p%numPylons*4), stat = errStat)
         ! allocate(rtrSpd(p%numPylons*4), stat = errStat)
         ! allocate(rtrAcc(p%numPylons*4), stat = errStat)
         ! allocate(rtrBladePitch(p%numPylons*4), stat = errStat)
         ! allocate(ctrlSettings(p%numFlaps*2+6), stat = errStat)

         c = 1
         wingOffset = 2*p%numPylons
         do j=1,p%numPylons
            do i=1,2         !RRD changed to keep CIM order in out and input
               !o%AeroTorq(c)              = u%SPyAeroTorque(i,j)
               !o%AeroTorq(c + wingOffset) = u%PPyAeroTorque(i,j)
               cp=(i-1)*(p%numPylons+j) + (2-i)*(p%nRotors+1-j-p%numPylons)
               cs=(i-1)*(p%numPylons-j+1) + (2-i)*(p%nRotors-p%numPylons+j)
               o%AeroTorq(cs)              = u%SPyAeroTorque(i,j)
               o%AeroTorq(cp)              = u%PPyAeroTorque(i,j)
               !c = c + 1
            end do
         end do

            ! print *, " ========================================"
            ! print *, ">>>>>>>> KFC_Step - Inputs at time = ", t, "<<<<<<<<<<<<<<<<<<<<< \n"
            ! print *, " debug - SPyAeroTorque: ", u%SPyAeroTorque
            ! print *, " debug - PPyAeroTorque: ", u%PPyAeroTorque
            ! print *, " debug - AeroTorq     : ", AeroTorq
            ! print *, " debug - pqr          : ", u%pqr
            ! print *, " debug - acc_norm     : ", u%acc_norm
            ! print *, " debug - Xg           : ", u%Xg
            ! print *, " debug - Vg           : ", u%Vg
            ! print *, " debug - Vb           : ", u%Vb
            ! print *, " debug - Ag           : ", u%Ag
            ! print *, " debug - Ab           : ", u%Ab
            ! print *, " debug - apparent_wind: ", u%apparent_wind
            ! print *, " debug - tether_forceb: ", u%tether_forceb
            ! print *, " debug - wind_g       : ", u%wind_g

            ! Call the DLL (first associate the address from the procedure in the DLL with the subroutine):
         call C_F_PROCPOINTER( p%DLL_Trgt%ProcAddr(2), DLL_KFC_Step_Subroutine) 
         call DLL_KFC_Step_Subroutine ( t_c, dcm_g2b_c, pqr_c, acc_norm_c, Xg_c, Vg_c, Vb_c, Ag_c, Ab_c, rho_c, apparent_wind_c, tether_forceb_c, wind_g_c, o%AeroTorq, o%genTorq, o%rtrSpd, o%rtrAcc, o%rtrBladePitch, o%ctrlSettings, errStat, errMsg_c ) 
         call c_to_fortran_string(errMsg_c, errMsg)

          ! print *, " KFC_Step errStat - ", errStat, " errMsg - ", trim(errMsg)
            ! print *, " KFC_Step - Outputs "
            ! print *, " debug - genTorq     : ", genTorq
            ! print *, " debug - rtrSpd      : ", rtrSpd
            ! print *, " debug - ctrlSettings: ", ctrlSettings
            ! print *, " ========================================"

         ! obtain initial outputs from the DLL and set them
         !!call KFC_MapOutputs(p%numFlaps, p%numPylons, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, y)  
         !call KFC_MapOutputs(p, u,  y, m, o,  rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg)
         !call KFC_MapOutputs(p, u,  y, m, o,  errStat, errMsg)
         ! print *, " debug - y%SFlp : ", y%SFlp
         ! print *, " debug - y%PFlp : ", y%PFlp
         ! print *, " debug - y%Rudr : ", y%Rudr
         ! print *, " debug - y%SElv : ", y%SElv
         ! print *, " debug - y%PElv : ", y%PElv
         ! print *, " ======================================="
      END SELECT   
         
   ! Map the output quantities to the AllOuts array --RRD
   CALL  KFC_MapOutputs(p, u,  y, m, o,  errStat, errMsg)
      if ( errStat >= AbortErrLev ) return
   

   !...............................................................................................................................
   ! Place the selected output channels into the WriteOutput(:) array with the proper sign:
   !...............................................................................................................................

   dO i = 1,p%NumOuts  ! Loop through all selected output channels
      y%WriteOutput(i) = p%OutParam(i)%SignM * m%AllOuts( p%OutParam(i)%Indx )
   end do             ! i - All selected output channels
   

   if (p%OutSwtch /= 2) call KFC_WrOutputLine(t, p, y%WriteOutput, errStat, errMsg) !RRD
   
   !print *, ">>>>>>>> RRD_Debug: In ",routineName," t, p%OutSwtch: ", t, p%OutSwtch," <<<<<<<<<<<<<<<<<<<<< \n"  

   
   end subroutine KFC_Step
   
   subroutine c_to_fortran_string(input, output)
      character(kind=C_CHAR), intent(in) :: input(IntfStrLen)
      character(*), intent(out) :: output
      character(1024) :: temp_string
      temp_string = transfer(input(1:1024), output)
      call RemoveNullChar(temp_string)
      output = trim(temp_string)
   end subroutine

!Next is all RRD's doing
   !====================================================================================================
   SUBROUTINE KFC_OpenOutput( ProgVer, OutRootName,  p, InitOut, ErrStat, ErrMsg )
   ! This subroutine initialized the output module, checking if the output parameter list (OutList)
   ! contains valid names, and opening the output file if there are any requested outputs
   !----------------------------------------------------------------------------------------------------
         ! Passed variables
   
      TYPE(ProgDesc),                INTENT( IN    ) :: ProgVer
      CHARACTER(*),                  INTENT( IN    ) :: OutRootName          ! Root name for the output file
      TYPE(KFC_ParameterType),        INTENT( INOUT ) :: p   
      TYPE(KFC_InitOutPutType ),      INTENT( IN    ) :: InitOut              !
      INTEGER,                       INTENT(   OUT ) :: ErrStat              ! a non-zero value indicates an error occurred           
      CHARACTER(*),                  INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None
      
         ! Local variables
      INTEGER                                        :: I                    ! Generic loop counter      
      CHARACTER(1024)                                :: OutFileName          ! The name of the output file  including the full path.
      CHARACTER(200)                                 :: Frmt                 ! a string to hold a format statement
      INTEGER                                        :: ErrStat2              
      character(*), parameter                       :: routineName = 'KFC_OpenOutput'
      !-------------------------------------------------------------------------------------------------      
      ! Initialize local variables
      !-------------------------------------------------------------------------------------------------      
      ErrStat = ErrID_None  
      ErrMsg  = ""
      p%OutSFmt = "A10"      
      !-------------------------------------------------------------------------------------------------      
      ! Open the output file, if necessary, and write the header
      !-------------------------------------------------------------------------------------------------      
      
      !print *, ">>>>>>>> RRD_Debug: In ",routineName,"  <<<<<<<<<<<<<<<<<<<<< \n"  
      IF ( ALLOCATED( p%OutParam ) .AND. p%NumOuts > 0 ) THEN           ! Output has been requested so let's open an output file            
         
            ! Open the file for output
         OutFileName = TRIM(OutRootName)//'.KFC.out'
         
        !!RRD hardcode here in case of dummy controller
         !!print *, ">>>>>>>> RRD_Debug: In ",routineName," OutFileName=", trim(OutFileName),"LEN_TRIM(OutRootName)=", LEN_TRIM(OutRootName)," <<<<<<<<<<<<<<<<<<<<< \n"  
        
       !!  IF (len_trim(OutFileName) .EQ. 1024) THEN 
       !!      OutFileName="./Kite.KFC.out"
       !!      print *, ">>>>>>>> RRD_Debug: In ",routineName,"  -- trim(OutFileName)=", trim(OutFileName)
       !!  ENDIF    

         CALL GetNewUnit( p%UnOutFile )
      
         CALL OpenFOutFile ( p%UnOutFile, OutFileName, ErrStat, ErrMsg ) 
         IF ( ErrStat >= AbortErrLev ) THEN
            ErrMsg = ' Error opening KiteFastController-level output file: '//TRIM(ErrMsg)
            RETURN
         END IF
         !print *, ">>>>>>>> RRD_Debug: In ",routineName," - p%UnOutFile ="//trim(OutFileName), " Unitfile=",p%UnOutFile
         
          
            ! Write the output file header
         
         WRITE (p%UnOutFile,'(/,A/)', IOSTAT=ErrStat2)  'These predictions were generated by '//TRIM(GETNVD(ProgVer))//&
                         ' on '//CurDate()//' at '//CurTime()//'.'
         
         WRITE(p%UnOutFile, '(//)') ! add 3 lines to make file format consistant with FAST v8 (headers on line 7; units on line 8) [this allows easier post-processing]
         
            ! Write the names of the output parameters:
         
         Frmt = '(A8,'//TRIM(Int2LStr(p%NumOuts))//'(:,A,'//TRIM( p%OutSFmt )//'))'
      
         WRITE(p%UnOutFile,Frmt, IOSTAT=ErrStat2)  TRIM( 'Time' ), ( p%Delim, TRIM( p%OutParam(I)%Name ), I=1,p%NumOuts )
                           
         
            ! Write the units of the output parameters:                 
         WRITE(p%UnOutFile,Frmt, IOSTAT=ErrStat2)  TRIM( 's'), ( p%Delim, TRIM( p%OutParam(I)%Units ), I=1,p%NumOuts )
                        
      
         
      END IF   ! there are any requested outputs   
      
      !print *, ">>>>>>>> RRD_Debug: End of ",routineName,"  <<<<<<<<<<<<<<<<<<<<<"
      RETURN
      
   END SUBROUTINE KFC_OpenOutput
   
   !====================================================================================================
   
   !====================================================================================================
   SUBROUTINE KFC_WrOutputLine( t, p, WriteOutputs, ErrStat, ErrMsg)
   ! This routine writes the module output to the output file.
   !----------------------------------------------------------------------------------------------------
   
      IMPLICIT                        NONE
      
         ! Passed variables
      REAL(DbKi), INTENT(IN)                  :: t                                  !< Current simulation time, in seconds
      TYPE(KFC_ParameterType), INTENT(IN)     :: p                                  !< KAD parameters
      REAL(ReKi),               INTENT(IN)    :: WriteOutputs (:)                   !< KAD WriteOutput values
      INTEGER(IntKi),           INTENT(OUT)   :: ErrStat                            !< Error status
      CHARACTER(*),             INTENT(OUT)   :: ErrMsg                             !< Error message
   
         ! Local variables.
   
      CHARACTER(200)                   :: Frmt                                      ! A string to hold a format specifier
      CHARACTER(10)                    :: TmpStr                                    ! temporary string to print the time output as text
   
      
      ErrStat = ErrID_None
      ErrMsg  = ''
      
    
            ! Write one line of tabular output:
      !   Frmt = '(F8.3,'//TRIM(Num2LStr(p%NumOuts))//'(:,A,'//TRIM( p%OutFmt )//'))'
         Frmt = '"'//p%Delim//'"'//p%OutFmt      ! format for array elements from individual modules
   
               ! time
         WRITE( TmpStr, '(F10.4)' ) t
         CALL WrFileNR( p%UnOutFile, TmpStr )
   
            ! write the individual module output (convert to SiKi if necessary, so that we don't need to print so many digits in the exponent)
         CALL WrNumAryFileNR ( p%UnOutFile, REAL(WriteOutputs,SiKi), Frmt, ErrStat, ErrMsg )
            !IF ( ErrStat >= AbortErrLev ) RETURN
         
            ! write a new line (advance to the next line)
         WRITE (p%UnOutFile,'()')
         
   END SUBROUTINE KFC_WrOutputLine
   
   !====================================================================================================
   SUBROUTINE KFC_CloseOutput ( p, ErrStat, ErrMsg )
   ! This function cleans up after running the SubDyn output module. It closes the output file,
   ! releases memory, and resets the number of outputs requested to 0.
   !----------------------------------------------------------------------------------------------------
   
            ! Passed variables
   
      TYPE(KFC_ParameterType),  INTENT( INOUT )  :: p                    ! data for this instance of the floating platform module        
      INTEGER,                       INTENT(   OUT ) :: ErrStat              ! a non-zero value indicates an error occurred           
      CHARACTER(*),                  INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None
   
   !      ! Internal variables
      LOGICAL                               :: Err
   
   
      !-------------------------------------------------------------------------------------------------
      ! Initialize error information
      !-------------------------------------------------------------------------------------------------
      ErrStat = 0
      ErrMsg  = ""
      
      Err     = .FALSE.
   
      !-------------------------------------------------------------------------------------------------
      ! Close our output file
      !-------------------------------------------------------------------------------------------------
      CLOSE( p%UnOutFile, IOSTAT = ErrStat )
      IF ( ErrStat /= 0 ) Err = .TRUE.
   
      !-------------------------------------------------------------------------------------------------
      ! Close Dummy Ctrl Data File
      !-------------------------------------------------------------------------------------------------
      CLOSE( p%UnCtrlFile, IOSTAT = ErrStat )
      IF ( ErrStat /= 0 ) Err = .TRUE.
  
    
      !-------------------------------------------------------------------------------------------------
      ! Make sure ErrStat is non-zero if an error occurred
      !-------------------------------------------------------------------------------------------------
      IF ( Err ) ErrStat = ErrID_Fatal
      
      RETURN
   
   END SUBROUTINE KFC_CloseOutput
   !==================================================================================================== 
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine parse the KFC input file.
   subroutine ReadKFCFile(InitInp, interval, p, errStat, errMsg)

      type(KFC_InitInputType),          intent(inout)  :: InitInp              !< Initialization input data for KiteFastController
      real(DbKi),                       intent(in   )  :: interval             !< Default time step for controller calculations, s
      TYPE(KFC_ParameterType),          INTENT( INOUT ):: p                    !< parameters
      integer(IntKi),                   intent(  out)  :: errStat              !< Error status of the operation
      character(*),                     intent(  out)  :: errMsg               !< Error message if errStat /= ErrID_None
   
            ! Local variables
      integer(IntKi)            :: i                ! loop counter
      character(ErrMsgLen)      :: errMsg2          ! temporary Error message if errStat /= ErrID_None
      integer(IntKi)            :: errStat2         ! temporary Error status of the operation
      character(1024)           :: fileName,homedir,sodir    ! file name, homedirectory, and directory of the .so ctrl file
      integer(IntKi)            :: UnIn, UnEc       ! file units
      character(1024)           :: FTitle           ! "File Title": the 2nd line of the input file, which contains a description of its contents
      logical                   :: Echo             ! echo flag, true=echo the file
      character(*), parameter   :: routineName = 'ReadKFCFile'
      
            ! Initialize variables for this routine
      errStat  = ErrID_None
      errMsg   = ""
      UnEc     = -1 
      Echo = .false.   
      fileName = trim(InitInp%InputFileName)
      
      call GetNewUnit( UnIn )   
     
      call OpenFInpfile(UnIn, trim(fileName), errStat, errMsg)
         if ( errStat /= ErrID_None ) then
            errStat = ErrID_Fatal
            return
         end if
    
      ! Read the lines up/including to the "Echo" simulation control variable
      ! If echo is FALSE, don't write these lines to the echo file. 
      ! If Echo is TRUE, rewind and write on the second try.
      
      i = 1 !set the number of times we've read the file
      do 
      !----------- HEADER -------------------------------------------------------------
      
         call ReadCom( UnIn, fileName, 'KiteFastController input file header (line 1)', errStat2, errMsg2, UnEc )
            call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
      
         call ReadStr( UnIn, fileName, FTitle, 'FTitle', 'KiteFastController input file header: File Description (line 2)', errStat2, errMsg2, UnEc )
            call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
            if ( errStat >= AbortErrLev ) then
               call Cleanup()
               return
            end if
      
   
      !-------------------------- SIMULATION CONTROL ------------------------
   
         ! Skip the comment line.
      call ReadCom( UnIn, fileName, ' SIMULATION CONTROL ', errStat2, errMsg2  ) 
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
         
         ! Echo - Echo input to "<RootName>.KFC.ech".
      
      call ReadVar( UnIn, fileName, Echo, 'Echo',   'Echo flag', errStat2, errMsg2, UnEc )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
      
      
      if (.NOT. Echo .OR. i > 1) EXIT !exit this loop
      
         ! Otherwise, open the echo file, then rewind the input file and echo everything we've read
         
      i = i + 1         ! make sure we do this only once (increment counter that says how many times we've read this file)
      
      call OpenEcho ( UnEc, trim(filename)//'.ech', errStat2, errMsg2, KFC_Ver )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
         if ( errStat >= AbortErrLev ) then
            close(UnIn)
            return
         end if
      
      if ( UnEc > 0 )  write (UnEc,'(/,A,/)')  'Data from '//trim(KFC_Ver%Name)//' primary input file "'//trim( fileName )//'":'
            
      rewind( UnIn, IOSTAT=errStat2 )  
         if (errStat2 /= 0_IntKi ) then
            call SetErrStat( ErrID_Fatal, 'Error rewinding file "'//trim(fileName)//'".', errStat, errMsg, RoutineName )
            call Cleanup()
            return
         end if           
      end do    
   
      if (NWTC_VerboseLevel == NWTC_Verbose) then
         call WrScr( ' Header of the '//trim(KFC_Ver%Name)//' input file: ' )      
         call WrScr( '   '//trim( FTitle ) )
      end if
      
      
         ! DTctrl - Time interval for controller calculations {or default} (s):
      
      call ReadVarWDefault( UnIn, fileName, InitInp%InpFileData%DTctrl, "DTctrl", "Time interval for controller calculations {or default} (s)", interval, errStat2, errMsg2, UnEc)
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
         ! DLL_FileName - The actual controller .so file  
         
      call ReadVar( UnIn, fileName, InitInp%InpFileData%DLL_FileName, "DLL_FileName", "C-controller DLL (9).so)  {or default}", errStat2, errMsg2, UnEc)
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
       print *, routineName//":  Requested InitInp%InpFileData%DLL_FileName=",InitInp%InpFileData%DLL_FileName
       
       IF ( ( trim(InitInp%InpFileData%DLL_FileName) == 'DEFAULT' ) .OR. ( trim(InitInp%InpFileData%DLL_FileName) == 'default' ) ) InitInp%InpFileData%DLL_FileName= trim(DLL_FileName_Default)
         sodir=trim(InitInp%InpFileData%DLL_FileName) 
         IF ( sodir(1:2) == "~/" ) THEN
            call GET_ENVIRONMENT_VARIABLE("HOME", homedir)   
            print *, routineName//": HOME ="//trim(homedir)   
            sodir = homedir(:LNBLNK(homedir))//sodir(2:LNBLNK(sodir))
         ENDIF      
         
         InitInp%InpFileData%DLL_FileName =sodir 
         print *, routineName//": Now Using InitInp%InpFileData%DLL_FileName=",InitInp%InpFileData%DLL_FileName  
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
         !-------------------------- INITIAL CONDITIONS ------------------------

      CALL ReadCom( UnIn, fileName, 'Section Header: Initial Conditions', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
      END IF

      ! rtrBladePitch - Rotor blade pitches [1 to NRotOuts] 
      CALL ReadAry( UnIn, fileName, InitInp%InpFileData%rtrBladePitch, p%nRotors, "rtrBladePitch", "List of initial rotor blade pitches (rad) [nRotors]", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF

      ! genTorq - Gen torques [1 to NRotOuts] 
      CALL ReadAry( UnIn, fileName, InitInp%InpFileData%genTorq, p%nRotors, "genTorq", "List of initial generator torques (Nm) [nRotors]", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF

      ! rtrSpd - rotor speeds [1 to NRotOuts] 
      CALL ReadAry( UnIn, fileName, InitInp%InpFileData%rtrSpd, p%nRotors, "rtrSpd", "List of initial rotor speeds (rad/s) [nRotors]", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF

      ! rtrAcc - rotor accels [1 to NRotOuts] 
      CALL ReadAry( UnIn, fileName, InitInp%InpFileData%rtrAcc, p%nRotors, "rtrAcc", "List of initial rotor accels (rad/s^2) [nRotors]", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF

      ! ctrlSettings - flap initial deflections [1 to 8 (most flaps in CSIM)] 
      CALL ReadAry( UnIn, fileName, InitInp%InpFileData%ctrlSettings, p%nCtrlSettings, "ctrlSettings", "List of initial flap delflections (rad) [nCtrlSettings]", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
       !---------------------- DUMMY CONTROLLER DATA FILE --------------------------------------------------
      CALL ReadCom( UnIn, fileName, 'Section Header: DUMMY CONTROLLER DATA FILE ', ErrStat2, ErrMsg2, UnEc )
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
 
      CALL ReadVar ( UnIn, fileName, InitInp%InpFileData%DmyCtl_FName, 'AFNames', 'Dummy Controller Filename', errStat2, errMsg2, UnEc )
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )  
  
         !---------------------- OUTPUT --------------------------------------------------

      CALL ReadCom( UnIn, fileName, 'Section Header: Output', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
         ! SumPrint - Print summary data to <RootName>.sum (flag):
      CALL ReadVar( UnIn, fileName, InitInp%InpFileData%SumPrint, "SumPrint", "Print summary data to <RootName>.sum (flag)", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
         ! OutSwtch - Switch to determine where output will be placed: (1: in module output file only; 2: in glue code output file only; 3: both) (-):
      CALL ReadVar( UnIn, fileName, InitInp%InpFileData%OutSwtch, "OutSwtch", "Switch to determine where output will be placed: (1: in module output file only; 2: in glue code output file only; 3: both) (-)", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
      !   ! TabDelim - Flag to cause tab-delimited text output (delimited by space otherwise) (flag):
      !CALL ReadVar( UnIn, fileName, InitInp%InpFileData%TabDelim, "TabDelim", "Flag to cause tab-delimited text output (delimited by space otherwise) (flag)", ErrStat2, ErrMsg2, UnEc)
      !   CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      !   IF ( ErrStat >= AbortErrLev ) THEN
      !      CALL Cleanup()
      !      RETURN
      !   END IF
   
         ! OutFmt - Format used for module's text tabular output (except time); resulting field should be 10 characters (-):
      CALL ReadVar( UnIn, fileName, InitInp%InpFileData%OutFmt, "OutFmt", "Format used for module's text tabular output (except time); resulting field should be 10 characters (-)", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
         
         ! NRotOuts - Number of rotor outputs (-) [0 to 9]:
      CALL ReadVar( UnIn, fileName, InitInp%InpFileData%NRotOuts, "NRotOuts", "Number of rotor utputs (-) [0 to 9]", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
         IF ( InitInp%InpFileData%NRotOuts > p%nRotors ) THEN
            CALL SetErrStat( ErrID_Warn, 'Number of requested rotors outputs exceeds '// &
                                         TRIM(Num2LStr(4*InitInp%numPylons))//'.', ErrStat, ErrMsg, RoutineName )
            IF ( ErrStat >= AbortErrLev ) THEN
               CALL Cleanup()
               RETURN
            END IF
            InitInp%InpFileData%NRotOuts = p%nRotors
         END IF
         
         ! RotOuts - List of rotors whose values will be output (-) [1 to NRotOuts] [unused for NrotOuts=0]:
      CALL ReadAry( UnIn, fileName, InitInp%InpFileData%RotOuts, InitInp%InpFileData%NRotOuts, "RotOuts", "List of rotors whose gentorque will be output (-) [1 to NRotOuts] [unused for NRotOuts=0]", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
                                            !_______________________________!
         ! NFlpOuts - Number of flaps outputs (-) [0 to 9]:
         CALL ReadVar( UnIn, fileName, InitInp%InpFileData%NFlpOuts, "NFlpOuts", "Number of rotor utputs (-) [0 to 9]", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
         IF ( InitInp%InpFileData%NFlpOuts > p%nCtrlSettings ) THEN
            CALL SetErrStat( ErrID_Warn, 'Number of requested flaps outputs exceeds '// &
                                         TRIM(Num2LStr(2*InitInp%numFlaps+2))//'.', ErrStat, ErrMsg, RoutineName )
            IF ( ErrStat >= AbortErrLev ) THEN
               CALL Cleanup()
               RETURN
            END IF
            InitInp%InpFileData%NFlpOuts = p%nCtrlSettings
            !!print *, ">>>>>RRD_debug: In ",RoutineName," InitInp%InpFileData%NFlpOuts=",InitInp%InpFileData%NFlpOuts
         END IF
         
         ! FlpOuts - List of flaps whose values will be output (-) [1 to NFlpOuts] [unused for NFlpOuts=0]:
      CALL ReadAry( UnIn, fileName, InitInp%InpFileData%FlpOuts, InitInp%InpFileData%NFlpOuts, "FlpOuts", "List of flaps whose deflections will be output (-) [1 to NFlpOuts] [unused for NFlpOuts=0]", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
         
      !---------------------- OUTLIST  --------------------------------------------
      CALL ReadCom( UnIn, fileName, 'Section Header: OutList', errStat2, errMsg2, UnEc )
         CALL SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
         ! OutList - List of user-requested output channels (-):
      CALL AllocAry( InitInp%InpFileData%OutList, MaxOutPts, "KiteFastController Input File's Outlist", ErrStat2, ErrMsg2 )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
      CALL ReadOutputList ( UnIn, fileName, InitInp%InpFileData%OutList, InitInp%InpFileData%NumOuts, 'OutList', "List of user-requested output channels", errStat2, errMsg2, UnEc  )     ! Routine in NWTC Subroutine Library
         CALL SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
         IF ( errStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
      
   contains
      
            !====================================================================================================
            subroutine Cleanup()
            !     The routine cleans up the module echo file and resets the NWTC_Library, reattaching it to 
            !     any existing echo information
            !----------------------------------------------------------------------------------------------------  
         
               print *, ">>>>>RRD_debug: In ",RoutineName," ErrMsg=",errMsg     
               close(UnIn)
               if ( UnEc > 0 ) close(UnEc)
               
            end subroutine Cleanup
            
   end subroutine ReadKFCFile
   !----------------------------------------------------------------------------------------------------------------------------------
!< This routine is called as part of the initialization step.
!< The parameters are set here and not changed during the simulation.
!< The initial states and initial guess for the input are defined.
   subroutine ValidateInitData(InitInp, KFCmode, errStat, errMsg)

   type(KFC_InitInputType),          intent(in   )  :: InitInp
   integer(IntKi),                   intent(in   )  :: KFCmode     !< type of controller
   integer(IntKi),                   intent(  out)  :: errStat     !< Error status of the operation
   character(*),                     intent(  out)  :: errMsg      !< Error message if errStat /= ErrID_None

         ! Local variables
   character(*), parameter                      :: routineName = 'ValidateInitData'
   type(KFC_InputFile)                          :: InpData
   
         ! Initialize variables for this routine
   errStat = ErrID_None
   errMsg  = ""
   InpData = InitInp%InpFileData
   
   if ( InpData%DTctrl   <= 0.0_DbKi ) call SetErrStat( ErrID_Fatal, 'Simulation timestep must be greater than zero', errStat, errMsg, routineName )
   if ( (KFCmode == 1) .AND. (InpData%DTctrl   .NE. 0.01_DbKi ) ) call SetErrStat( ErrID_Fatal, 'Simulation timestep <> 0.01s , and that does not match CSIM ctrl', errStat, errMsg, routineName )
 
   if ( InpData%NRotOuts >8 ) call SetErrStat( ErrID_Fatal, 'Number of generators must be less than 8', errStat, errMsg, routineName )
   if ( (InpData%OutSwtch   < 1) .or. (InpData%OutSwtch   > 3) ) call SetErrStat( ErrID_Fatal, 'OutSwtch must be set to 1=KiteAeroDyn.out, 2=GlueCode.out, 3=both files', errStat, errMsg, routineName )
   
   
   ! TODO: Decide what we will check in terms of the node coordinates and viability of component geometry
   
   end subroutine ValidateInitData
   
   !====================================================================================================
   SUBROUTINE KFC_OpenDmyFile( o, p, ErrStat, ErrMsg )
      ! This subroutine initializes the dummy controller data file for reading,
      ! contains valid names, and opening the output file if there are any requested outputs
      !----------------------------------------------------------------------------------------------------
            ! Passed variables
         TYPE(KFC_OtherStateType), INTENT(INOUT) :: o                                  !< KAD other states (ctrl outputs
         TYPE(KFC_ParameterType),        INTENT( INOUT ) :: p   
         INTEGER,                       INTENT(   OUT ) :: ErrStat              ! a non-zero value indicates an error occurred           
         CHARACTER(*),                  INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None
         
            ! Local variables
         INTEGER                                        :: ErrStat2      
         CHARACTER(ErrMsgLen)                           :: errMsg2          ! temporary Error message if errStat /= ErrID_None        
         character(*), parameter                       :: routineName = 'KFC_OpenDmyFile'
         !-------------------------------------------------------------------------------------------------      
         ! Initialize local variables
         !-------------------------------------------------------------------------------------------------      
         ErrStat = ErrID_None  
         ErrMsg  = ""
          
         !-------------------------------------------------------------------------------------------------      
         ! Open the data file
         !-------------------------------------------------------------------------------------------------      
         
         print *, ">>>>>>>> RRD_Debug: In ",routineName," CtrlFile=", trim(p%DmyCtl_FName)," <<<<<<<<<<<<<<<<<<<<< \n"  
        
         CALL GetNewUnit( p%UnCtrlFile )
      
         CALL OpenFInpFile ( p%UnCtrlFile, p%DmyCtl_FName, ErrStat2, ErrMsg2) 
            CALL SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
         if ( errStat >= AbortErrLev ) then
            ErrMsg = ' Error opening DummyController-level data file: '//TRIM(ErrMsg)
            close(p%UnCtrlFile)
            return
         end if

         p%CtrlLineLength  =  (p%nCtrlSettings+p%nRotors*4) +1      !flaps per wing+el/rud + rotor related fields + time channel
         Call AllocAry( o%OneCtrlLine, p%CtrlLineLength, 'p%OneCtrlLine', errStat2, errMsg2 )
            Call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
         
         !Then Call Readoneliner for t=0 ctrl info (skip first lines) and rewind file for the next kfc_step still at t=0
         Call ReadCom( p%UnCtrlFile, p%DmyCtl_FName, 'KiteFastController Ctrl data file header (line 1)', errStat2, errMsg2 )
            call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
         Call ReadCom( p%UnCtrlFile, p%DmyCtl_FName, 'KiteFastController Ctrl data file header (line 2)', errStat2, errMsg2 )
            call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
         Call ReadCom( p%UnCtrlFile, p%DmyCtl_FName, 'KiteFastController Ctrl data file: Units header line', errStat2, errMsg2 )
            call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
            if ( errStat >= AbortErrLev ) then
               call Cleanup()
               return
            end if
      
   
         CALL KFC_RdCtrlDataLine( o, p, ErrStat, ErrMsg)
         BackSpace( p%UnCtrlFile, IOSTAT=errStat2 )  
         if (errStat2 /= 0_IntKi ) then
            call SetErrStat( ErrID_Fatal, 'Error rewinding file "'//trim(p%DmyCtl_FName)//'".', errStat, errMsg, RoutineName )
            call Cleanup()
            return
         end if           
            !print *, ">>>>>>>> RRD_Debug: End of ",routineName,"  <<<<<<<<<<<<<<<<<<<<<"
                    !====================================================================================================
         contains
         subroutine Cleanup()
            !     The routine closes the file in case of problems
               print *, ">>>>>RRD_debug: In ",RoutineName," ErrMsg=",errMsg
               close(p%UnCtrlFile)
         end subroutine Cleanup      

      END SUBROUTINE KFC_OpenDmyFile
  !====================================================================================================
      SUBROUTINE KFC_RdCtrlDataLine( o, p, ErrStat, ErrMsg)
         ! This routine reads the data from control data file when called and assigns them to structure "o"
         !-----------------------------------------------------------------------------------------------
            IMPLICIT                        NONE
            
               ! Passed variables
            TYPE(KFC_ParameterType), INTENT(IN)     :: p                                  !< KAD parameters
            TYPE(KFC_OtherStateType), INTENT(INOUT) :: o                                  !< KAD other states (ctrl outputs
            
            INTEGER(IntKi),           INTENT(OUT)   :: ErrStat                            !< Error status
            CHARACTER(*),             INTENT(OUT)   :: ErrMsg                             !< Error message
         
               ! Local variables.
            
            INTEGER                                        :: ErrStat2  
            CHARACTER(ErrMsgLen)                           :: errMsg2        ! The error message, if an error occurred
            character(*), parameter                       :: routineName = 'KFC_RdCtrlDataLine'
            ErrStat = ErrID_None
            ErrMsg  = ''
            
            
            CALL ReadAry( p%UnCtrlFile, p%DmyCtl_FName, o%OneCtrlLine, p%CtrlLineLength, "OneLine", "Array of controls GenTorqs[p%nRrotors](Nm), rtrSpd[p%nRrotors] (rad/s), rtrAcc[p%nRrotors] (rad/s^2), rtrBladePitch[p%nRrotors] (rad), ctrlSettings[p%numflaps] (rad) ", ErrStat2, ErrMsg2)
            
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
            IF ( ErrStat >= AbortErrLev ) THEN
               
               CALL Cleanup()
               RETURN
            END IF
            
            !print *, ">>>>>>RRD_Debug:  In ", routineName, " read-in t=", o%OneCtrlLine(1)

            o%genTorq        = o%OneCtrlLine(2:p%nRotors+1)
            o%rtrSpd         = o%OneCtrlLine(p%nRotors+2:2*p%nRotors+1)
            o%rtrAcc         = o%OneCtrlLine(2*p%nRotors+2:3*p%nRotors+1)
            o%rtrBladePitch  = o%OneCtrlLine(3*p%nRotors+2:4*p%nRotors+1)
            o%ctrlSettings   = o%OneCtrlLine(4*p%nRotors+2:4*p%nRotors+1+p%nCtrlSettings)

            contains
            subroutine Cleanup()
               !     The routine closes the file in case of problems
                  close(p%UnCtrlFile)
            end subroutine Cleanup      
         
         END SUBROUTINE KFC_RdCtrlDataLine
         
         !====================================================================================================
end module KiteFastController
