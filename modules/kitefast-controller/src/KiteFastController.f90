!**********************************************************************************************************************************
!> ## KFC
!! The KiteFastController  module implements a controller for the KiteFAST code. 
!! KiteFastController_Types will be auto-generated by the FAST registry program, based on the variables specified in the
!! KiteFastController_Registry.txt file.
!!
! ..................................................................................................................................
!! ## LICENSING 
!! Copyright (C) 2019  National Renewable Energy Laboratory
!!
!!    This file is part of KiteFAST.
!!
!! Licensed under the Apache License, Version 2.0 (the "License");
!! you may not use this file except in compliance with the License.
!! You may obtain a copy of the License at
!!
!!     http://www.apache.org/licenses/LICENSE-2.0
!!
!! Unless required by applicable law or agreed to in writing, software
!! distributed under the License is distributed on an "AS IS" BASIS,
!! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!! See the License for the specific language governing permissions and
!! limitations under the License.
!**********************************************************************************************************************************
module KiteFastController

   use KiteFastController_Types
   use NWTC_Library
   use KiteFastController_IO  !RRD
   use, intrinsic :: ISO_C_Binding
   
   implicit none
   private
   
   integer,        parameter    :: IntfStrLen  = 1025       ! length of strings through the C interface
   type(ProgDesc), parameter    :: KFC_Ver = ProgDesc( 'KiteFastController', '', '' )

      !> Definition of the DLL Interface for the KiteFast Controller
      !! 
   abstract interface
      subroutine KFC_DLL_Init_PROC ( dt, numFlaps, numPylons, rtrIrot, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg )  BIND(C)
         use, intrinsic :: ISO_C_Binding
         real(C_DOUBLE), value,  intent(in   ) :: dt                  !< required simulation time step
         integer(C_INT), value,  intent(in   ) :: numFlaps            !< number of flaps per wing in the Kite model
         integer(C_INT), value,  intent(in   ) :: numPylons           !< number of pylons per wing in the Kite model
         real(C_DOUBLE),         intent(in   ) :: rtrIrot(*)          !< The rotor rotational inertias (m^3), follows ordering for genTorq. !RRD Why m^3????
         real(C_DOUBLE),         intent(inout) :: genTorq(*)          !< The initial generator torques, specified as Top Rotor then Bottom Rotor for inboard Starboard pylon, 
                                                                      !<   then repeat moving outboard.  Then repeat for port side, starting inboard and moving outboard.
         real(C_DOUBLE),         intent(inout) :: rtrSpd(*)           !< The initial rotor speeds (rad/s), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: rtrAcc(*)           !< The initial rotor accelerations (rad/s^2), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: rtrBladePitch(*)    !< The initial rotor-collective blade pitch angles (rad), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: ctrlSettings(*)     !< The initial control surfaces angles(rad), Starts with starboard wing flaps (numFlaps of them), then port wing flaps, 
                                                                      !<   then 2 rudder values, then 2 starboard elevators, then 2 port elevators.
         integer(C_INT),         intent(  out) :: errStat             !< error status code (uses NWTC_Library error codes)
         character(kind=C_CHAR), intent(inout) :: errMsg          (*) !< Error Message from DLL to simulation code        
      end subroutine KFC_DLL_Init_PROC   
   end interface   

   abstract interface
      subroutine KFC_DLL_Step_PROC ( t_c, dcm_g2b_c, pqr_c, acc_norm_c, Xg_c, Vg_c, Vb_c, Ag_c, Ab_c, rho_c, apparent_wind_c, &
         tether_forceb_c, wind_g_c, aeroTorq, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg )  BIND(C)
         use, intrinsic :: ISO_C_Binding
         real(C_DOUBLE), value,  intent(in   ) :: t_c                 !<simulation time (s)
         real(C_DOUBLE),         intent(in   ) :: dcm_g2b_c(9)
         real(C_DOUBLE),         intent(in   ) :: pqr_c(3)          
         real(C_DOUBLE),         intent(in   ) :: acc_norm_c    
         real(C_DOUBLE),         intent(in   ) :: Xg_c(3)           
         real(C_DOUBLE),         intent(in   ) :: Vg_c(3)           
         real(C_DOUBLE),         intent(in   ) :: Vb_c(3)           
         real(C_DOUBLE),         intent(in   ) :: Ag_c(3)           
         real(C_DOUBLE),         intent(in   ) :: Ab_c(3)           
         real(C_DOUBLE),         intent(in   ) :: rho_c          
         real(C_DOUBLE),         intent(in   ) :: apparent_wind_c(3)
         real(C_DOUBLE),         intent(in   ) :: tether_forceb_c(3) 
         real(C_DOUBLE),         intent(in   ) :: wind_g_c(3) 
         real(C_DOUBLE),         intent(in   ) :: aeroTorq(*)           !< The aerodynamic torques.  See genTorq, below for ordering.
         real(C_DOUBLE),         intent(inout) :: genTorq(*)            !< The generator torques, specified as Top Rotor then Bottom Rotor for inboard Starboard pylon, 
                                                                        !<   then repeat moving outboard.  Then repeat for port side, starting inboard and moving outboard.
         real(C_DOUBLE),         intent(inout) :: rtrSpd(*)             !< The rotor speeds (rad/s), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: rtrAcc(*)             !< The rotor accelerations (rad/s^2), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: rtrBladePitch(*)      !< The rotor-collective blade pitch angles (rad), follows ordering for genTorq.
         real(C_DOUBLE),         intent(inout) :: ctrlSettings(*)       !< The control surfaces angles(rad), Starts with starboard wing flaps (numFlaps of them), then port wing flaps, 
                                                                        !<   then 2 rudder values, then 2 starboard elevators, then 2 port elevators.
         integer(C_INT),         intent(inout) :: errStat               !< error status code (uses NWTC_Library error codes)
         character(kind=C_CHAR), intent(inout) :: errMsg(1025)          !< Error Message from DLL to simulation code        
      end subroutine KFC_DLL_Step_PROC                                  
   end interface   
 
   abstract interface
      subroutine KFC_DLL_END_PROC ( errStat, errMsg )  BIND(C)
         use, intrinsic :: ISO_C_Binding
         integer(C_INT),         intent(  out) :: errStat             !< error status code (uses NWTC_Library error codes)
         character(kind=C_CHAR), intent(inout) :: errMsg          (*) !< Error Message from DLL to simulation code        
      end subroutine KFC_DLL_END_PROC   
   end interface   

   public :: KFC_Init                     ! Initialization routine
   public :: KFC_End                      ! Ending routine (includes clean up)
   public :: KFC_Step                     ! Routine for computing outputs and internally updating states
  
   contains   
   
   
!   subroutine MapKFCOutputs( numFlaps, numPylons, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, y)
!   subroutine KFC_MapOutputs(p, u,  y, m, o,  rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg)
   subroutine KFC_MapOutputs(p, u,  y, m, o,   errStat, errMsg)
      type(KFC_ParameterType),       intent(in   )  :: p           !< KFC Parameters
      type(KFC_InputType),           intent(in   )  :: u           !< KFC inputs
      type(KFC_OutputType),          intent(inout)  :: y           !< KFC system outputs 
      type(KFC_MiscVarType),         intent(inout)  :: m           !< KFC MiscVars for the module
      type(KFC_OtherStateType),      intent(in   )  :: o           !< KFC Other states, containing C-SIM output                            
      integer(IntKi),                intent(  out)  :: errStat     !< Error status of the operation
      character(*),                  intent(  out)  :: errMsg      !< Error message if errStat /= ErrID_None
      
      character(*), parameter     :: RoutineName = 'KFC_MapOutputs'
     
!      integer(IntKi),       intent(in   ) :: numFlaps
!      integer(IntKi),       intent(in   ) :: numPylons
     ! real(C_DOUBLE),       intent(in   ) :: genTorq(:)
      !real(C_DOUBLE),       intent(in   ) :: rtrSpd(:)
      !!real(C_DOUBLE),       intent(in   ) :: rtrAcc(:)
      !real(C_DOUBLE),       intent(in   ) :: rtrBladePitch(:)
      !real(C_DOUBLE),       intent(in   ) :: ctrlSettings(:)
      
      
      integer(IntKi)                :: wingOffset, i, j, c

     errStat = ErrID_None
     errMsg  = ''

         ! Set outputs to zero for now
      c = 1
      wingOffset = 2*p%numPylons
      do j=1,p%numPylons
         do i=1,2
            y%SPyGenTorque(i,j) = o%genTorq(c)
            !print *, ">>>>>>>> RRD_debug In",RoutineName,"o%genTorq(c)=",o%genTorq(c)," <<<<<<<<<<<<<<<<<<<<< \n" 
            y%PPyGenTorque(i,j) = o%genTorq(c + wingOffset)
            y%SPyRtrSpd(i,j)    = o%rtrSpd(c)
            y%PPyRtrSpd(i,j)    = o%rtrSpd(c + wingOffset)
            y%SPyRtrAcc(i,j)    = o%rtrAcc(c)
            y%PPyRtrAcc(i,j)    = o%rtrAcc(c + wingOffset)
            y%SPyBldPitch(i,j)  = o%rtrBladePitch(c)
            y%PPyBldPitch(i,j)  = o%rtrBladePitch(c + wingOffset)
            !print *, ">>>>>>>> RRD_debug In ",RoutineName," o%genTorq(c+ wingOffset)=",o%genTorq(c+ wingOffset),"y%PPyGenTorque(i,j)=",y%PPyGenTorque(i,j), " <<<<<<<<<<<<<<<<<<<<< \n" 
            c = c + 1
            
         end do
      end do
      
      !RRD: To me the following looks all wrong, so I am redoing the mapping below:
      !y%SFlp         = o%ctrlSettings(1:p%numFlaps)
      !y%PFlp         = o%ctrlSettings(p%numFlaps+1:2*p%numFlaps)
      !y%Rudr         = o%ctrlSettings(2*p%numFlaps+1:2*p%numFlaps+2)
      !y%SElv         = o%ctrlSettings(2*p%numFlaps+3:2*p%numFlaps+4)
      !y%PElv         = o%ctrlSettings(2*p%numFlaps+5:2*p%numFlaps+6)

      y%PFlp         = o%ctrlSettings(1:p%numFlaps)
      y%SFlp         = o%ctrlSettings(p%numFlaps+1:2*p%numFlaps)
      
      y%PElv         = o%ctrlSettings(2*p%numFlaps+1)
      y%SElv         = o%ctrlSettings(2*p%numFlaps+1)
      
      y%Rudr         = o%ctrlSettings(2*p%numFlaps+2)



      !Set output file data ---RRD
    do i = 1, p%NRotOuts
               
         if (errStat >= AbortErrLev) then
            call SetErrStat( ErrID_Fatal, 'The Generators', errStat, errMsg, RoutineName )
            return
         end if
      
      m%AllOuts( GenTq(i) )  = o%genTorq(i)
      m%AllOuts( RotSpd(i) ) = o%rtrSpd(i)
      m%AllOuts( RotAtq(i) ) = o%AeroTorq(i)      
    end do
    
    do i = 1, p%NFlpOuts
 
      if (errStat >= AbortErrLev) then
         call SetErrStat( ErrID_Fatal, 'The Flaps', errStat, errMsg, RoutineName )
         return
      end if
 
      m%AllOuts( FlpDef(i) ) = o%ctrlSettings(i)

    end do

   end subroutine KFC_MapOutputs 
   
   subroutine KFC_End(p, errStat, errMsg)

      type(KFC_ParameterType),        intent(inout)  :: p               !< Parameters
      integer(IntKi),                 intent(  out)  :: errStat         !< Error status of the operation
      character(*),                   intent(  out)  :: errMsg          !< Error message if ErrStat /= ErrID_None

         ! local variables
      character(*), parameter                        :: routineName = 'KFC_End'
      integer(IntKi)                                 :: errStat2       ! The error status code
      character(ErrMsgLen)                           :: errMsg2        ! The error message, if an error occurred
      procedure(KFC_DLL_END_PROC),pointer            :: DLL_KFC_End_Subroutine       ! The address of the controller cc_end procedure in the DLL
      character(kind=C_CHAR)                         :: errMsg_c(IntfStrLen)
      errStat = ErrID_None
      errMsg= ''
      
      if (.not. p%useDummy) then
            ! Call the DLL's end subroutine:
         call C_F_PROCPOINTER( p%DLL_Trgt%ProcAddr(3), DLL_KFC_End_Subroutine) 
         call DLL_KFC_End_Subroutine ( errStat, errMsg_c ) 
         call c_to_fortran_string(errMsg_c, errMsg)
      
         print *, " KFC_End errStat - ", errStat, " errMsg - ", trim(errMsg)

         ! TODO: Check errors
      
            ! Free the library
         call FreeDynamicLib( p%DLL_Trgt, errStat2, errMsg2 )  
            call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      end if
      
   end subroutine KFC_End

   subroutine KFC_Init(InitInp, u, p, y, interval, m, o, InitOut, errStat, errMsg )
      
      type(KFC_InitInputType),      intent(inout   )  :: InitInp     !< Input data for initialization routine >>>RRD: made this inout instead of in
      type(KFC_InitOutputType),     intent(inout   )  :: InitOut     !< Output data for initialization routine >>>RRD added
      type(KFC_MiscVarType),        intent(  out)  :: m           !< MiscVars for the module >>>RRD added
      type(KFC_InputType),          intent(inout)  :: u           !< An initial guess for the input
      type(KFC_ParameterType),      intent(  out)  :: p           !< Parameters
      type(KFC_OutputType),         intent(  out)  :: y           !< Initial system outputs 
      type(KFC_OtherStateType),      intent(out   )  :: o           !< KFC Other states, containing C-SIM output                            

      real(DbKi),                   intent(inout)  :: interval    !< Coupling interval in seconds: 
                                                                  !<   Input is the timestep size requested by caller, returned is the Controller's required timestep
      integer(IntKi),               intent(  out)  :: errStat     !< Error status of the operation
      character(*),                 intent(  out)  :: errMsg      !< Error message if errStat /= ErrID_None
 
         ! local variables
      character(*), parameter                 :: routineName = 'KFC_Init'
      integer(IntKi)                          :: errStat2                     ! The error status code
      character(ErrMsgLen)                    :: errMsg2                      ! The error message, if an error occurred
      procedure(KFC_DLL_Init_PROC),pointer    :: DLL_KFC_Init_Subroutine       ! The address of the controller cc_init procedure in the DLL
      
      character(kind=C_CHAR)                  :: errMsg_c(IntfStrLen)
      !!real(C_DOUBLE), allocatable             :: rtrIrot(:), genTorq(:), rtrSpd(:), rtrAcc(:), rtrBladePitch(:), ctrlSettings(:)  !!RRD I replaced this with OtherStates in Registry
      real(C_DOUBLE)                          :: dt_c
      integer(IntKi)                          :: wingOffset, i, j, c
      
          
      errStat2 = ErrID_None
      errMsg2  = ''
   
      call DispNVD( KFC_Ver )  ! Display the version of this interface
      
         ! Check that key Kite model components match the requirements of this controller interface.
      !=============================================================================================
      ! NOTE: GJH: Perhaps a better design is to let the actual controller (shared object) determine if numFlaps and numPylons and interval are acceptable
      !
      !if (InitInp%numFlaps /= 3) call SetErrStat( ErrID_Fatal, 'The current KiteFAST controller interface requires numFlaps = 3', errStat, errMsg, routineName )
      !if (InitInp%numPylons /= 2) call SetErrStat( ErrID_Fatal, 'The current KiteFAST controller interface requires numPylons = 2', errStat, errMsg, routineName )
      !if (.not. EqualRealNos(interval, 0.01_DbKi)) call SetErrStat( ErrID_Fatal, 'The current KiteFAST controller interface requires DT = 0.01 seconds', errStat, errMsg, routineName )
      !   if (errStat >= AbortErrLev ) return
      !=============================================================================================  
      
               ! Set the module's parameters
      p%numFlaps  = InitInp%numFlaps
      p%numPylons = InitInp%numPylons
      interval    = 0.01_DbKi          ! Forcing a controller dt of 0.01 sec
      p%DT        = interval            
      p%useDummy  = InitInp%useDummy
      
         ! allocate the inputs and outputs
      call AllocAry( u%SPyAeroTorque, 2, p%numPylons, 'u%SPyAeroTorque', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( u%PPyAeroTorque, 2, p%numPylons, 'u%PPyAeroTorque', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%SPyGenTorque,  2, p%numPylons, 'y%SPyGenTorque',  errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PPyGenTorque,  2, p%numPylons, 'y%PPyGenTorque',  errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )   
      call AllocAry( y%SPyRtrSpd,     2, p%numPylons, 'y%SPyRtrSpd',     errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PPyRtrSpd,     2, p%numPylons, 'y%PPyRtrSpd',     errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )  
       call AllocAry( y%SPyRtrAcc,     2, p%numPylons, 'y%SPyRtrAcc',     errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PPyRtrAcc,     2, p%numPylons, 'y%PPyRtrAcc',     errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )  
      call AllocAry( y%SPyBldPitch,   2, p%numPylons, 'y%SPyBldPitch',   errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PPyBldPitch,   2, p%numPylons, 'y%PPyBldPitch',   errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )   
      call AllocAry( y%SFlp, p%numFlaps, 'y%SFlp', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( y%PFlp, p%numFlaps, 'y%PFlp', errStat2, errMsg2 )   
      !RRD added the following OtherStates
      call AllocAry( o%ctrlsettings,2*p%numFlaps+6, 'o%ctrlsettings', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( o%rtrSpd,4*p%numPylons, 'o%rtrSpd', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( o%rtrAcc,4*p%numPylons, 'o%rtrAcc', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( o%genTorq,4*p%numPylons, 'o%genTorq', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( o%rtrBladePitch,4*p%numPylons, 'o%rtrBladePitch', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( o%rtrIrot,4*p%numPylons, 'o%rtrIrot', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      call AllocAry( o%AeroTorq,2*p%numFlaps+2, 'o%AeroTorque', errStat2, errMsg2 )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
      
      
      if (errStat >= AbortErrLev ) return

      
      ! Are we simply using a dummy controller?  If so, we will skip trying to call into a DLL/SO      
      
      if (.not. p%useDummy) then
     
            ! Define and load the DLL:
         p%DLL_Trgt%FileName = InitInp%DLL_FileName

         p%DLL_Trgt%ProcName = "" ! initialize all procedures to empty so we try to load only one
         p%DLL_Trgt%ProcName(1) = 'kfc_dll_init'
         p%DLL_Trgt%ProcName(2) = 'kfc_dll_step'
         p%DLL_Trgt%ProcName(3) = 'kfc_dll_end'
      
         call LoadDynamicLib ( p%DLL_Trgt, errStat2, errMsg2 )
            call SetErrStat( errStat2, errMsg2, errStat, errMsg, routineName )
         if (errStat >= AbortErrLev ) return

         ! Now that the library is loaded, call the controller's kfc_dll_init routine

            ! Call the DLL (first associate the address from the procedure in the DLL with the subroutine):
         call C_F_PROCPOINTER( p%DLL_Trgt%ProcAddr(1), DLL_KFC_Init_Subroutine) 
      
         !RRD I replaced the following allocs with OtherStates above
         ! allocate(rtrIrot(p%numPylons*4), stat = errStat)
         ! allocate(genTorq(p%numPylons*4), stat = errStat)
         ! allocate(rtrSpd(p%numPylons*4), stat = errStat)
         ! allocate(rtrAcc(p%numPylons*4), stat = errStat)
         ! allocate(rtrBladePitch(p%numPylons*4), stat = errStat)
         ! allocate(ctrlSettings(p%numFlaps*2+6), stat = errStat)
         
         dt_c = real(interval, C_DOUBLE)  ! RRD replaced 0.01 with interval :This is hardcoded for the Makani Controller
         
         c = 1
         wingOffset = 2*p%numPylons
         do j=1,p%numPylons
            do i=1,2
               o%rtrIrot(c)              = InitInp%SPyRtrIrot(i,j)
               o%rtrIrot(c + wingOffset) = InitInp%PPyRtrIrot(i,j)
               c = c + 1
            end do
         end do
         
         !print *, ">>>>>>>> RRD_Debug: In ",routineName,"- dt_c, o%genTorq before DLL_INIT=",dt_c, o%genTorq, "<<<<<<<<<<<<<<<<"  
         !call DLL_KFC_Init_Subroutine ( dt_c, p%numFlaps*2+2, p%numPylons, rtrIrot, o%genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg_c ) 
         call DLL_KFC_Init_Subroutine ( dt_c, p%numFlaps*2+2, p%numPylons, o%rtrIrot, o%genTorq, o%rtrSpd, o%rtrAcc, o%rtrBladePitch, o%ctrlSettings, errStat, errMsg_c )  !RRD
         !print *, ">>>>>>>> RRD_Debug: In ",routineName,"- o%genTorq after DLL_INIT=",o%genTorq, "<<<<<<<<<<<<<<<<"  
         
         call c_to_fortran_string(errMsg_c, errMsg)
         ! print *, " KFC_Init errStat - ", errStat, " errMsg - ", trim(errMsg)
         ! TODO: Check errors
         !print *, " debug marker - pre errStat >= Abort"
         if (errStat >= AbortErrLev ) return
         
         !print *, " debug marker - post errStat >= Abort"
         !print *, " debug - o%genTorq     : ", o%genTorq
         ! print *, " debug - rtrSpd      : ", rtrSpd
         !print *, " debug - o%ctrlSettings: ", o%ctrlSettings
         
         ! obtain initial outputs from the DLL and set them
         !!call KFC_MapOutputs( p%numFlaps, p%numPylons, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, y)
        ! call KFC_MapOutputs(p, u,  y, m, o,  rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg)
      else
           ! Set outputs to zero except for RtrSpd which is set to be constant for the dummy controller
         !y%SPyGenTorque = 0.0_ReKi
         !y%PPyGenTorque = 0.0_ReKi
            ! TODO: Determine what would be a realistic dummy set of speed and the correct signs for each rotor
         o%genTorq=0.0_ReKi
         o%genTorq(3)=110.0_ReKi
         o%rtrSpd=100
         o%rtrSpd(1)=-100
         o%rtrSpd(3)=-100
         
         !y%SPyRtrSpd(1,1) = -100.0  ! starboard top rotor, inner pylons   rad/s
         !y%SPyRtrSpd(2,1) = 100.0  ! starboard bottom rotor, inner pylons     
         !y%PPyRtrSpd(1,1) = -100.0  ! port top rotor, inner pylons
         !y%PPyRtrSpd(2,1) = 100.0  ! port bottom rotor, inner pylons
         if ( p%numPylons > 1 ) then
            o%rtrSpd(5)=-100
            o%rtrSpd(7)=-100
            ! y%SPyRtrSpd(1,2) = 100.0  ! starboard top rotor, outer pylons 
            !y%SPyRtrSpd(2,2) = -100.0  ! starboard bottom rotor, outer pylons
            !y%PPyRtrSpd(1,2) = 100.0  ! port top rotor, outer pylon
            !y%PPyRtrSpd(2,2) = -100.0  ! port bottom rotor, outer pylon
         end if
         o%rtrAcc=10.0_ReKi  ! rad/s^2
         o%rtrAcc(3)=12.0_ReKi  ! rad/s^2
         !y%SPyRtrAcc    =   10.0_ReKi  ! rad/s^2
         !y%PPyRtrAcc    =   12.0_ReKi  ! rad/s^2
         o%rtrBladePitch=2.0_ReKi  ! deg ???
         o%rtrBladePitch(3)=1.0_ReKi  ! deg ???
         
         !y%SPyBldPitch  = 0.0_ReKi

         !y%PPyBldPitch  = 0.0_ReKi
            ! All flag commands are constant for the dummy controller
          !RRD I introduced o% for all otherstates, i.e. those given by external controller
         o%ctrlSettings(1:p%numFlaps)=0.1_ReKi !starboard flap
         o%ctrlSettings(p%numFlaps+1:2*p%numFlaps)=-0.3_ReKi !port flap
         o%ctrlSettings(2*p%numFlaps+1:2*p%numFlaps+2)=0.2_ReKi !rudder
         o%ctrlSettings(2*p%numFlaps+3:2*p%numFlaps+4)=0.4_ReKi ! starboard elevator
         o%ctrlSettings(2*p%numFlaps+5:2*p%numFlaps+6)=0.5_ReKi ! port elevator

         !y%SFlp =  0.1_ReKi
         !y%PFlp = -0.3_ReKi
         !y%Rudr =  0.2_ReKi
         !y%SElv =  0.4_ReKi
         !y%PElv =  0.5_ReKi
         
      end if
      
      !>>>>>>>>>>>>>>>>>>>>>>>>>RRD to the end of the subroutine KFC_Init<<<<<<<<<<<<<<<<<<<<<<<<<<<
      
      InitInp%Filename='./RRD_ctrl_input.dat'  !RRD:hardwire for now, it will be read elsewhere in the future from InitInp%Filename

      ! Read Input file, otherwise the caller must have fully populated the Initialization inputs
      if ( trim(InitInp%Filename) /= '' ) then
         call ReadKFCFile(InitInp, interval, errStat, errMsg)
         if ( errStat > ErrID_None ) return
         print *, ">>>>>>>> RRD_Debug: In ",routineName,"InitInp%Filename is ",InitInp%Filename," <<<<<<<<<<<<<<<<<<<<< \n"  
      endif
   
      ! Validate the input file data and issue errors as needed
      call ValidateInitData(InitInp, errStat, errMsg)
      if ( errStat >= AbortErrLev ) return

      
      !----------------------------------
      ! Create the file-related output data
      !----------------------------------
      allocate( m%AllOuts(0:MaxOutPts), STAT=errStat2 ) ! allocate starting at zero to account for invalid output channels
      IF ( ErrStat /= 0 )  THEN
         errStat = ErrID_Fatal
         errMsg  = ' Error allocating memory for the AllOuts array.'
         RETURN
      ENDIF   
      m%AllOuts   = 0.0_ReKi
      p%OutSwtch  = InitInp%InpFileData%OutSwtch
      p%NumOuts   = InitInp%InpFileData%NumOuts !this could be numouts instead
      p%NFlpOuts  = InitInp%InpFileData%NFlpOuts
      p%OutFmt    = InitInp%InpFileData%OutFmt
      p%NRotOuts  = InitInp%InpFileData%NRotOuts
      p%RotOuts   = InitInp%InpFileData%RotOuts


      !print *, ">>>>>RRD_debug: In ",RoutineName," p%NFlpOuts, p%NumOuts=",p%NFlpOuts, p%NumOuts
                  !!call KFC_MapOutputs( p%numFlaps, p%numPylons, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, y)
      call KFC_MapOutputs(p, u,  y, m, o,  errStat, errMsg)
      !call KFC_MapOutputs(p, u,  y, m, o,  rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg)

            ! Set parameters for output channels:
      CALL KFC_SetOutParam(InitInp%InpFileData%OutList, p, errStat, errMsg ) ! requires: p%NumOuts, p%NRotOuts; sets: p%OutParam.
         IF (ErrStat >= AbortErrLev) RETURN
   
      IF ( InitInp%InpFileData%TabDelim ) THEN
         p%Delim = TAB
      ELSE
         p%Delim = ' '
      END IF
   
      if ( p%OutSwtch == 2 .or. p%OutSwtch == 3 ) then
         CALL AllocAry( InitOut%WriteOutputHdr, p%NumOuts, 'WriteOutputHdr', ErrStat, ErrMsg )
            IF (ErrStat >= AbortErrLev) RETURN
         CALL AllocAry( InitOut%WriteOutputUnt, p%NumOuts, 'WriteOutputUnt', ErrStat, ErrMsg )
         
            IF (ErrStat >= AbortErrLev) RETURN
         
         do i=1,p%NumOuts
            InitOut%WriteOutputHdr(i) = p%OutParam(i)%Name
            InitOut%WriteOutputUnt(i) = p%OutParam(i)%Units
         end do
      end if

      ! Open and initialize the output file/data
      p%OutFileRoot = InitInp%OutFileRoot
      
      if (p%OutSwtch /= 2) then   
         call KFC_OpenOutput( KFC_Ver, p%OutFileRoot,  p, InitOut, ErrStat, ErrMsg )
            if (ErrStat >= AbortErrLev) return
      end if
      
      call AllocAry( y%WriteOutput, p%NumOuts, 'y%WriteOutput', ErrStat, ErrMsg )   
         if (ErrStat >= AbortErrLev) return
      y%WriteOutput = 0.0_ReKi
      
   !...............................................................................................................................
   ! Place the selected output channels into the WriteOutput(:) array with the proper sign:
   !...............................................................................................................................

      dO i = 1,p%NumOuts  ! Loop through all selected output channels
         y%WriteOutput(i) = p%OutParam(i)%SignM * m%AllOuts( p%OutParam(i)%Indx )
      end do             ! i - All selected output channels
   

      if (p%OutSwtch /= 2) call KFC_WrOutputLine(0.0_DbKi, p, y%WriteOutput, errStat, errMsg)

      print *, ">>>>>>>> RRD_Debug: At the end of ",routineName,"Passed <<<<<<<<<<<<<<<<<<<<< \n"  

   end subroutine KFC_Init

   subroutine KFC_Step(t, u, p, y, m, o, errStat, errMsg )
      real(DbKi),                    intent(in   )  :: t           !< Current simulation time in seconds
      type(KFC_InputType),           intent(in   )  :: u           !< Inputs at Time t
      type(KFC_ParameterType),       intent(in   )  :: p           !< Parameters
      type(KFC_OutputType),          intent(inout)  :: y           !< Outputs computed at t (Input only so that mesh con-
                                                                   !!   nectivity information does not have to be recalculated)
      type(KFC_MiscVarType),         intent(inout)  :: m           !< KFC MiscVars for the module
      type(KFC_OtherStateType),      intent(inout)  :: o           !< KFC Other states, containing C-SIM output; out just for dummy controller                            


      integer(IntKi),                intent(  out)  :: errStat     !< Error status of the operation
      character(*),                  intent(  out)  :: errMsg      !< Error message if ErrStat /= ErrID_None
   
      character(*), parameter                       :: routineName = 'KFC_Step'
      integer(IntKi)                                :: errStat2       ! The error status code
      character(ErrMsgLen)                          :: errMsg2        ! The error message, if an error occurred     
      procedure(KFC_DLL_Step_PROC),pointer          :: DLL_KFC_Step_Subroutine              ! The address of the supercontroller sc_calcoutputs procedure in the DLL
      real(C_DOUBLE)                                :: t_c
      real(C_DOUBLE)                                :: dcm_g2b_c(9)
      real(C_DOUBLE)                                :: pqr_c(3)
      real(C_DOUBLE)                                :: acc_norm_c
      real(C_DOUBLE)                                :: Xg_c(3)
      real(C_DOUBLE)                                :: Vg_c(3)
      real(C_DOUBLE)                                :: Vb_c(3)
      real(C_DOUBLE)                                :: Ag_c(3)
      real(C_DOUBLE)                                :: Ab_c(3)
      real(C_DOUBLE)                                :: rho_c          
      real(C_DOUBLE)                                :: apparent_wind_c(3)
      real(C_DOUBLE)                                :: tether_forceb_c(3) 
      real(C_DOUBLE)                                :: wind_g_c(3)       
      character(kind=C_CHAR)                        :: errMsg_c(IntfStrLen)

      !!real(C_DOUBLE), allocatable                   :: AeroTorq(:) , genTorq(:), rtrSpd(:), rtrAcc(:), rtrBladePitch(:), ctrlSettings(:)  !!RRD I replaced this with OtherStates in Registry
      integer(IntKi)                                :: c, i, j, wingOffset
      errStat2 = ErrID_None
      errMsg2  = ''
      
         ! Cast and massage inputs to match DLL datatypes
      t_c             = t
      dcm_g2b_c       = reshape(u%dcm_g2b,(/9/))
      pqr_c           = u%pqr
      acc_norm_c      = u%acc_norm
      Xg_c            = u%Xg
      Vg_c            = u%Vg
      Vb_c            = u%Vb
      Ag_c            = u%Ag
      Ab_c            = u%Ab
      rho_c           = u%rho
      apparent_wind_c = u%apparent_wind
      tether_forceb_c = u%tether_forceb
      wind_g_c        = u%wind_g
      
      !print *, ">>>>>>>> RRD_Debug: At the start of ",routineName," t=,",t,"  <<<<<<<<<<<<<<<<<<<<< \n"  

      if (.not. p%useDummy) then
         
         !RRD replaced the following with otherstates
         !allocate(AeroTorq(p%numPylons*4), stat = errStat)
         !allocate(genTorq(p%numPylons*4), stat = errStat)
         ! allocate(rtrSpd(p%numPylons*4), stat = errStat)
         ! allocate(rtrAcc(p%numPylons*4), stat = errStat)
         ! allocate(rtrBladePitch(p%numPylons*4), stat = errStat)
         ! allocate(ctrlSettings(p%numFlaps*2+6), stat = errStat)

         c = 1
         wingOffset = 2*p%numPylons
         do j=1,p%numPylons
            do i=1,2
               o%AeroTorq(c)              = u%SPyAeroTorque(i,j)
               o%AeroTorq(c + wingOffset) = u%PPyAeroTorque(i,j)
               c = c + 1
            end do
         end do

            ! print *, " ========================================"
            ! print *, ">>>>>>>> KFC_Step - Inputs at time = ", t, "<<<<<<<<<<<<<<<<<<<<< \n"
            ! print *, " debug - SPyAeroTorque: ", u%SPyAeroTorque
            ! print *, " debug - PPyAeroTorque: ", u%PPyAeroTorque
            ! print *, " debug - AeroTorq     : ", AeroTorq
            ! print *, " debug - pqr          : ", u%pqr
            ! print *, " debug - acc_norm     : ", u%acc_norm
            ! print *, " debug - Xg           : ", u%Xg
            ! print *, " debug - Vg           : ", u%Vg
            ! print *, " debug - Vb           : ", u%Vb
            ! print *, " debug - Ag           : ", u%Ag
            ! print *, " debug - Ab           : ", u%Ab
            ! print *, " debug - apparent_wind: ", u%apparent_wind
            ! print *, " debug - tether_forceb: ", u%tether_forceb
            ! print *, " debug - wind_g       : ", u%wind_g

            ! Call the DLL (first associate the address from the procedure in the DLL with the subroutine):
         call C_F_PROCPOINTER( p%DLL_Trgt%ProcAddr(2), DLL_KFC_Step_Subroutine) 
         call DLL_KFC_Step_Subroutine ( t_c, dcm_g2b_c, pqr_c, acc_norm_c, Xg_c, Vg_c, Vb_c, Ag_c, Ab_c, rho_c, apparent_wind_c, tether_forceb_c, wind_g_c, o%AeroTorq, o%genTorq, o%rtrSpd, o%rtrAcc, o%rtrBladePitch, o%ctrlSettings, errStat, errMsg_c ) 
         call c_to_fortran_string(errMsg_c, errMsg)

          ! print *, " KFC_Step errStat - ", errStat, " errMsg - ", trim(errMsg)
            ! print *, " KFC_Step - Outputs "
            ! print *, " debug - genTorq     : ", genTorq
            ! print *, " debug - rtrSpd      : ", rtrSpd
            ! print *, " debug - ctrlSettings: ", ctrlSettings
            ! print *, " ========================================"

         ! obtain initial outputs from the DLL and set them
         !!call KFC_MapOutputs(p%numFlaps, p%numPylons, genTorq, rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, y)  
         !call KFC_MapOutputs(p, u,  y, m, o,  rtrSpd, rtrAcc, rtrBladePitch, ctrlSettings, errStat, errMsg)
         !call KFC_MapOutputs(p, u,  y, m, o,  errStat, errMsg)
         ! print *, " debug - y%SFlp : ", y%SFlp
         ! print *, " debug - y%PFlp : ", y%PFlp
         ! print *, " debug - y%Rudr : ", y%Rudr
         ! print *, " debug - y%SElv : ", y%SElv
         ! print *, " debug - y%PElv : ", y%PElv
         ! print *, " ======================================="
         
      else
         
         ! TODO: Determine what would be a realistic dummy set of speed and the correct signs for each rotor
            ! NOTE: Speed should match the settings used in the Init routine.
         o%rtrSpd=(/-100.0,100.0,200.0,210.0,-300.0,310.0,400.0,-410.0/)
          !y%SPyRtrSpd(1,1) = -100.0  ! starboard top rotor, inner pylons    rad/s
         !y%SPyRtrSpd(2,1) = 100.0  ! starboard bottom rotor, inner pylons        
         !y%PPyRtrSpd(1,1) = -100.0  ! port top rotor, inner pylons
         !y%PPyRtrSpd(2,1) = 100.0  ! port bottom rotor, inner pylons
         
         !if ( p%numPylons > 1 ) then
         !   y%SPyRtrSpd(1,2) = 100.0  ! starboard top rotor, outer pylons 
          !  y%SPyRtrSpd(2,2) = -100.0  ! starboard bottom rotor, outer pylons
           ! y%PPyRtrSpd(1,2) = 100.0  ! port top rotor, outer pylon
            !y%PPyRtrSpd(2,2) = -100.0  ! port bottom rotor, outer pylon
         !end if
            ! Zero rotor acceleration
         o%rtrSpd=(/-10.0,10.0,11.0,-12.0,-30.0,31.0,22.0,-22.0/)
         !y%SPyRtrAcc(1,:) = 10.0_ReKi ! starboard top rotor, all pylons 
         !y%SPyRtrAcc(2,:) = 11.0_ReKi ! starboard bottom rotor, all pylons
         !y%PPyRtrAcc(1,:) = 12.0_ReKi ! port top rotor, all pylons
         !y%PPyRtrAcc(2,:) = 13.0_ReKi ! port bottom rotor, all pylons
         

            ! Currently blade pitch is not being set by controller and was initialized to 0.0
         o%rtrBladePitch= 0.0_ReKi
         !y%SPyBldPitch  = 0.0_ReKi
         !y%PPyBldPitch  = 0.0_ReKi
         
            ! Set GenTorque = -AeroTorque
         o%genTorq=(/-123.0,123.0,111.0,-112.0,-320.0,131.0,122.0,-121.0/)
         !y%SPyGenTorque = -u%SPyAeroTorque  ! starboard rotors
         !y%PPyGenTorque = -u%PPyAeroTorque  ! port rotors
        
            ! All flag commands are constant for the dummy controller
         o%ctrlSettings(1:p%numFlaps)=-0.1_ReKi !starboard flap
         o%ctrlSettings(p%numFlaps+1:2*p%numFlaps)=+0.3_ReKi !port flap
         o%ctrlSettings(2*p%numFlaps+1:2*p%numFlaps+2)=-0.2_ReKi !rudder
         o%ctrlSettings(2*p%numFlaps+3:2*p%numFlaps+4)=-0.4_ReKi ! starboard elevator
         o%ctrlSettings(2*p%numFlaps+5:2*p%numFlaps+6)=-0.5_ReKi ! port elevator

         !y%SFlp =  0.1_ReKi
         !y%PFlp = -0.3_ReKi
         !y%Rudr =  0.2_ReKi
         !y%SElv =  0.4_ReKi
         !y%PElv =  0.5_ReKi
         
      end if
      
         ! Map the output quantities to the AllOuts array --RRD
   
   call  KFC_MapOutputs(p, u,  y, m, o,  errStat, errMsg)
      if ( errStat >= AbortErrLev ) return
      
   !...............................................................................................................................
   ! Place the selected output channels into the WriteOutput(:) array with the proper sign:
   !...............................................................................................................................

   dO i = 1,p%NumOuts  ! Loop through all selected output channels
      y%WriteOutput(i) = p%OutParam(i)%SignM * m%AllOuts( p%OutParam(i)%Indx )
   end do             ! i - All selected output channels
   

   if (p%OutSwtch /= 2) call KFC_WrOutputLine(t, p, y%WriteOutput, errStat, errMsg) !RRD
   
   !print *, ">>>>>>>> RRD_Debug: In ",routineName," t, p%OutSwtch: ", t, p%OutSwtch," <<<<<<<<<<<<<<<<<<<<< \n"  

   
   end subroutine KFC_Step
   
   subroutine c_to_fortran_string(input, output)
      character(kind=C_CHAR), intent(in) :: input(IntfStrLen)
      character(*), intent(out) :: output
      character(1024) :: temp_string
      temp_string = transfer(input(1:1024), output)
      call RemoveNullChar(temp_string)
      output = trim(temp_string)
   end subroutine

!Next is all RRD's doing
   !====================================================================================================
   SUBROUTINE KFC_OpenOutput( ProgVer, OutRootName,  p, InitOut, ErrStat, ErrMsg )
   ! This subroutine initialized the output module, checking if the output parameter list (OutList)
   ! contains valid names, and opening the output file if there are any requested outputs
   !----------------------------------------------------------------------------------------------------
         ! Passed variables
   
      TYPE(ProgDesc),                INTENT( IN    ) :: ProgVer
      CHARACTER(*),                  INTENT( IN    ) :: OutRootName          ! Root name for the output file
      TYPE(KFC_ParameterType),        INTENT( INOUT ) :: p   
      TYPE(KFC_InitOutPutType ),      INTENT( IN    ) :: InitOut              !
      INTEGER,                       INTENT(   OUT ) :: ErrStat              ! a non-zero value indicates an error occurred           
      CHARACTER(*),                  INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None
      
         ! Local variables
      INTEGER                                        :: I                    ! Generic loop counter      
      CHARACTER(1024)                                :: OutFileName          ! The name of the output file  including the full path.
      CHARACTER(200)                                 :: Frmt                 ! a string to hold a format statement
      INTEGER                                        :: ErrStat2              
      character(*), parameter                       :: routineName = 'KFC_OpenOutput'
      !-------------------------------------------------------------------------------------------------      
      ! Initialize local variables
      !-------------------------------------------------------------------------------------------------      
      ErrStat = ErrID_None  
      ErrMsg  = ""
      p%OutSFmt = "A10"      
      !-------------------------------------------------------------------------------------------------      
      ! Open the output file, if necessary, and write the header
      !-------------------------------------------------------------------------------------------------      
      
      !print *, ">>>>>>>> RRD_Debug: In ",routineName,"  <<<<<<<<<<<<<<<<<<<<< \n"  
      IF ( ALLOCATED( p%OutParam ) .AND. p%NumOuts > 0 ) THEN           ! Output has been requested so let's open an output file            
         
            ! Open the file for output
         OutFileName = TRIM(OutRootName)//'.KFC.out'
         
        !!RRD hardcode here in case of dummy controller
         print *, ">>>>>>>> RRD_Debug: In ",routineName," OutFileName=", trim(OutFileName),"LEN_TRIM(OutRootName)=", LEN_TRIM(OutRootName)," <<<<<<<<<<<<<<<<<<<<< \n"  
        
       !!  IF (len_trim(OutFileName) .EQ. 1024) THEN 
       !!      OutFileName="./Kite.KFC.out"
       !!      print *, ">>>>>>>> RRD_Debug: In ",routineName,"  -- trim(OutFileName)=", trim(OutFileName)
       !!  ENDIF    

         CALL GetNewUnit( p%UnOutFile )
      
         CALL OpenFOutFile ( p%UnOutFile, OutFileName, ErrStat, ErrMsg ) 
         IF ( ErrStat >= AbortErrLev ) THEN
            ErrMsg = ' Error opening KiteFastController-level output file: '//TRIM(ErrMsg)
            RETURN
         END IF
         !print *, ">>>>>>>> RRD_Debug: In ",routineName," - p%UnOutFile ="//trim(OutFileName), " Unitfile=",p%UnOutFile
         
          
            ! Write the output file header
         
         WRITE (p%UnOutFile,'(/,A/)', IOSTAT=ErrStat2)  'These predictions were generated by '//TRIM(GETNVD(ProgVer))//&
                         ' on '//CurDate()//' at '//CurTime()//'.'
         
         WRITE(p%UnOutFile, '(//)') ! add 3 lines to make file format consistant with FAST v8 (headers on line 7; units on line 8) [this allows easier post-processing]
         
            ! Write the names of the output parameters:
         
         Frmt = '(A8,'//TRIM(Int2LStr(p%NumOuts))//'(:,A,'//TRIM( p%OutSFmt )//'))'
      
         WRITE(p%UnOutFile,Frmt, IOSTAT=ErrStat2)  TRIM( 'Time' ), ( p%Delim, TRIM( p%OutParam(I)%Name ), I=1,p%NumOuts )
                           
         
            ! Write the units of the output parameters:                 
         WRITE(p%UnOutFile,Frmt, IOSTAT=ErrStat2)  TRIM( 's'), ( p%Delim, TRIM( p%OutParam(I)%Units ), I=1,p%NumOuts )
                        
      
         
      END IF   ! there are any requested outputs   
      
      !print *, ">>>>>>>> RRD_Debug: End of ",routineName,"  <<<<<<<<<<<<<<<<<<<<<"
      RETURN
      
   END SUBROUTINE KFC_OpenOutput
   
   !====================================================================================================
   
   !====================================================================================================
   SUBROUTINE KFC_WrOutputLine( t, p, WriteOutputs, ErrStat, ErrMsg)
   ! This routine writes the module output to the output file.
   !----------------------------------------------------------------------------------------------------
   
      IMPLICIT                        NONE
      
         ! Passed variables
      REAL(DbKi), INTENT(IN)                  :: t                                  !< Current simulation time, in seconds
      TYPE(KFC_ParameterType), INTENT(IN)     :: p                                  !< KAD parameters
      REAL(ReKi),               INTENT(IN)    :: WriteOutputs (:)                   !< KAD WriteOutput values
      INTEGER(IntKi),           INTENT(OUT)   :: ErrStat                            !< Error status
      CHARACTER(*),             INTENT(OUT)   :: ErrMsg                             !< Error message
   
         ! Local variables.
   
      CHARACTER(200)                   :: Frmt                                      ! A string to hold a format specifier
      CHARACTER(10)                    :: TmpStr                                    ! temporary string to print the time output as text
   
      
      ErrStat = ErrID_None
      ErrMsg  = ''
      
    
            ! Write one line of tabular output:
      !   Frmt = '(F8.3,'//TRIM(Num2LStr(p%NumOuts))//'(:,A,'//TRIM( p%OutFmt )//'))'
         Frmt = '"'//p%Delim//'"'//p%OutFmt      ! format for array elements from individual modules
   
               ! time
         WRITE( TmpStr, '(F10.4)' ) t
         CALL WrFileNR( p%UnOutFile, TmpStr )
   
            ! write the individual module output (convert to SiKi if necessary, so that we don't need to print so many digits in the exponent)
         CALL WrNumAryFileNR ( p%UnOutFile, REAL(WriteOutputs,SiKi), Frmt, ErrStat, ErrMsg )
            !IF ( ErrStat >= AbortErrLev ) RETURN
         
            ! write a new line (advance to the next line)
         WRITE (p%UnOutFile,'()')
         
   END SUBROUTINE KFC_WrOutputLine
   
   !====================================================================================================
   SUBROUTINE KFC_CloseOutput ( p, ErrStat, ErrMsg )
   ! This function cleans up after running the SubDyn output module. It closes the output file,
   ! releases memory, and resets the number of outputs requested to 0.
   !----------------------------------------------------------------------------------------------------
   
            ! Passed variables
   
      TYPE(KFC_ParameterType),  INTENT( INOUT )  :: p                    ! data for this instance of the floating platform module        
      INTEGER,                       INTENT(   OUT ) :: ErrStat              ! a non-zero value indicates an error occurred           
      CHARACTER(*),                  INTENT(   OUT ) :: ErrMsg               ! Error message if ErrStat /= ErrID_None
   
   !      ! Internal variables
      LOGICAL                               :: Err
   
   
      !-------------------------------------------------------------------------------------------------
      ! Initialize error information
      !-------------------------------------------------------------------------------------------------
      ErrStat = 0
      ErrMsg  = ""
      
      Err     = .FALSE.
   
      !-------------------------------------------------------------------------------------------------
      ! Close our output file
      !-------------------------------------------------------------------------------------------------
      CLOSE( p%UnOutFile, IOSTAT = ErrStat )
      IF ( ErrStat /= 0 ) Err = .TRUE.
   
     
    
      !-------------------------------------------------------------------------------------------------
      ! Make sure ErrStat is non-zero if an error occurred
      !-------------------------------------------------------------------------------------------------
      IF ( Err ) ErrStat = ErrID_Fatal
      
      RETURN
   
   END SUBROUTINE KFC_CloseOutput
   !==================================================================================================== 
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine parse the KiteAeroDyn input file.
   subroutine ReadKFCFile(InitInp, interval, errStat, errMsg)

      type(KFC_InitInputType),          intent(inout)  :: InitInp     !< Initialization input data for KiteFastController
      real(DbKi),                       intent(in   )  :: interval    !< Default time step for controller calculations, s
      integer(IntKi),                   intent(  out)  :: errStat     !< Error status of the operation
      character(*),                     intent(  out)  :: errMsg      !< Error message if errStat /= ErrID_None
   
            ! Local variables
      integer(IntKi)            :: i                ! loop counter
      character(ErrMsgLen)      :: errMsg2          ! temporary Error message if errStat /= ErrID_None
      integer(IntKi)            :: errStat2         ! temporary Error status of the operation
      character(1024)           :: fileName         ! file name
      integer(IntKi)            :: UnIn, UnEc       ! file units
      character(1024)           :: FTitle           ! "File Title": the 2nd line of the input file, which contains a description of its contents
      logical                   :: Echo             ! echo flag, true=echo the file
      character(*), parameter   :: routineName = 'ReadKFCFile'
      
            ! Initialize variables for this routine
      errStat  = ErrID_None
      errMsg   = ""
      UnEc     = -1 
      Echo = .false.   
      fileName = trim(InitInp%Filename)
      
      call GetNewUnit( UnIn )   
     
      call OpenFInpfile(UnIn, trim(fileName), errStat, errMsg)
         if ( errStat /= ErrID_None ) then
            errStat = ErrID_Fatal
            return
         end if
    
      ! Read the lines up/including to the "Echo" simulation control variable
      ! If echo is FALSE, don't write these lines to the echo file. 
      ! If Echo is TRUE, rewind and write on the second try.
      
      i = 1 !set the number of times we've read the file
      do 
      !----------- HEADER -------------------------------------------------------------
      
         call ReadCom( UnIn, fileName, 'KiteFastController input file header (line 1)', errStat2, errMsg2, UnEc )
            call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
      
         call ReadStr( UnIn, fileName, FTitle, 'FTitle', 'KiteFastController input file header: File Description (line 2)', errStat2, errMsg2, UnEc )
            call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
            if ( errStat >= AbortErrLev ) then
               call Cleanup()
               return
            end if
      
   
      !-------------------------- SIMULATION CONTROL ------------------------
   
         ! Skip the comment line.
      call ReadCom( UnIn, fileName, ' SIMULATION CONTROL ', errStat2, errMsg2  ) 
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
         
         ! Echo - Echo input to "<RootName>.KFC.ech".
      
      call ReadVar( UnIn, fileName, Echo, 'Echo',   'Echo flag', errStat2, errMsg2, UnEc )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
      
      
      if (.NOT. Echo .OR. i > 1) EXIT !exit this loop
      
         ! Otherwise, open the echo file, then rewind the input file and echo everything we've read
         
      i = i + 1         ! make sure we do this only once (increment counter that says how many times we've read this file)
      
      call OpenEcho ( UnEc, trim(filename)//'.ech', errStat2, errMsg2, KFC_Ver )
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
         if ( errStat >= AbortErrLev ) then
            close(UnIn)
            return
         end if
      
      if ( UnEc > 0 )  write (UnEc,'(/,A,/)')  'Data from '//trim(KFC_Ver%Name)//' primary input file "'//trim( fileName )//'":'
            
      rewind( UnIn, IOSTAT=errStat2 )  
         if (errStat2 /= 0_IntKi ) then
            call SetErrStat( ErrID_Fatal, 'Error rewinding file "'//trim(fileName)//'".', errStat, errMsg, RoutineName )
            call Cleanup()
            return
         end if           
      end do    
   
      if (NWTC_VerboseLevel == NWTC_Verbose) then
         call WrScr( ' Heading of the '//trim(KFC_Ver%Name)//' input file: ' )      
         call WrScr( '   '//trim( FTitle ) )
      end if
      
      
         ! DTctrl - Time interval for controller calculations {or default} (s):
      
      call ReadVarWDefault( UnIn, fileName, InitInp%InpFileData%DTctrl, "DTctrl", "Time interval for controller calculations {or default} (s)", interval, errStat2, errMsg2, UnEc)
         call SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
 
         !---------------------- OUTPUT --------------------------------------------------
      CALL ReadCom( UnIn, fileName, 'Section Header: Output', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
         ! SumPrint - Print summary data to <RootName>.sum (flag):
      CALL ReadVar( UnIn, fileName, InitInp%InpFileData%SumPrint, "SumPrint", "Print summary data to <RootName>.sum (flag)", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
         ! OutSwtch - Switch to determine where output will be placed: (1: in module output file only; 2: in glue code output file only; 3: both) (-):
      CALL ReadVar( UnIn, fileName, InitInp%InpFileData%OutSwtch, "OutSwtch", "Switch to determine where output will be placed: (1: in module output file only; 2: in glue code output file only; 3: both) (-)", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
      !   ! TabDelim - Flag to cause tab-delimited text output (delimited by space otherwise) (flag):
      !CALL ReadVar( UnIn, fileName, InitInp%InpFileData%TabDelim, "TabDelim", "Flag to cause tab-delimited text output (delimited by space otherwise) (flag)", ErrStat2, ErrMsg2, UnEc)
      !   CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      !   IF ( ErrStat >= AbortErrLev ) THEN
      !      CALL Cleanup()
      !      RETURN
      !   END IF
   
         ! OutFmt - Format used for module's text tabular output (except time); resulting field should be 10 characters (-):
      CALL ReadVar( UnIn, fileName, InitInp%InpFileData%OutFmt, "OutFmt", "Format used for module's text tabular output (except time); resulting field should be 10 characters (-)", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
         
         ! NRotOuts - Number of rotor outputs (-) [0 to 9]:
      CALL ReadVar( UnIn, fileName, InitInp%InpFileData%NRotOuts, "NRotOuts", "Number of rotor utputs (-) [0 to 9]", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
         IF ( InitInp%InpFileData%NRotOuts > 4*InitInp%numPylons ) THEN
            CALL SetErrStat( ErrID_Warn, 'Number of requested rotors outputs exceeds '// &
                                         TRIM(Num2LStr(4*InitInp%numPylons))//'.', ErrStat, ErrMsg, RoutineName )
            IF ( ErrStat >= AbortErrLev ) THEN
               CALL Cleanup()
               RETURN
            END IF
            InitInp%InpFileData%NRotOuts = 4*InitInp%numPylons
         END IF
         
         ! RotOuts - List of rotors whose values will be output (-) [1 to NRotOuts] [unused for NrotOuts=0]:
      CALL ReadAry( UnIn, fileName, InitInp%InpFileData%RotOuts, InitInp%InpFileData%NRotOuts, "RotOuts", "List of rotors whose gentorque will be output (-) [1 to NRotOuts] [unused for NRotOuts=0]", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
                                            !_______________________________!
         ! NFlpOuts - Number of flaps outputs (-) [0 to 9]:
         CALL ReadVar( UnIn, fileName, InitInp%InpFileData%NFlpOuts, "NFlpOuts", "Number of rotor utputs (-) [0 to 9]", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
         IF ( InitInp%InpFileData%NFlpOuts > 2*InitInp%numFlaps+2 ) THEN
            CALL SetErrStat( ErrID_Warn, 'Number of requested flaps outputs exceeds '// &
                                         TRIM(Num2LStr(2*InitInp%numFlaps+2))//'.', ErrStat, ErrMsg, RoutineName )
            IF ( ErrStat >= AbortErrLev ) THEN
               CALL Cleanup()
               RETURN
            END IF
            InitInp%InpFileData%NFlpOuts = 2*InitInp%numFlaps+2
            print *, ">>>>>RRD_debug: In ",RoutineName," InitInp%InpFileData%NFlpOuts=",InitInp%InpFileData%NFlpOuts
         END IF
         
         ! FlpOuts - List of flaps whose values will be output (-) [1 to NFlpOuts] [unused for NFlpOuts=0]:
      CALL ReadAry( UnIn, fileName, InitInp%InpFileData%FlpOuts, InitInp%InpFileData%NFlpOuts, "FlpOuts", "List of rotors whose gentorque will be output (-) [1 to NFlpOuts] [unused for NFlpOuts=0]", ErrStat2, ErrMsg2, UnEc)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
         
      !---------------------- OUTLIST  --------------------------------------------
      CALL ReadCom( UnIn, fileName, 'Section Header: OutList', errStat2, errMsg2, UnEc )
         CALL SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
         ! OutList - List of user-requested output channels (-):
      CALL AllocAry( InitInp%InpFileData%OutList, MaxOutPts, "KiteFastController Input File's Outlist", ErrStat2, ErrMsg2 )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
      CALL ReadOutputList ( UnIn, fileName, InitInp%InpFileData%OutList, InitInp%InpFileData%NumOuts, 'OutList', "List of user-requested output channels", errStat2, errMsg2, UnEc  )     ! Routine in NWTC Subroutine Library
         CALL SetErrStat( errStat2, errMsg2, errStat, errMsg, RoutineName )
         IF ( errStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
      
   contains
      
            !====================================================================================================
            subroutine Cleanup()
            !     The routine cleans up the module echo file and resets the NWTC_Library, reattaching it to 
            !     any existing echo information
            !----------------------------------------------------------------------------------------------------  
         
                    
               close(UnIn)
               if ( UnEc > 0 ) close(UnEc)
               
            end subroutine Cleanup
            
   end subroutine ReadKFCFile
   !----------------------------------------------------------------------------------------------------------------------------------
!< This routine is called as part of the initialization step.
!< The parameters are set here and not changed during the simulation.
!< The initial states and initial guess for the input are defined.
   subroutine ValidateInitData(InitInp, errStat, errMsg)

   type(KFC_InitInputType),          intent(in   )  :: InitInp
   integer(IntKi),                   intent(  out)  :: errStat     !< Error status of the operation
   character(*),                     intent(  out)  :: errMsg      !< Error message if errStat /= ErrID_None

         ! Local variables
   character(*), parameter                      :: routineName = 'ValidateInitData'
   type(KFC_InputFile)                          :: InpData
   
         ! Initialize variables for this routine
   errStat = ErrID_None
   errMsg  = ""
   InpData = InitInp%InpFileData
   
   if ( InpData%DTctrl   <= 0.0_DbKi ) call SetErrStat( ErrID_Fatal, 'Simulation timestep must be greater than zero', errStat, errMsg, routineName )
   if ( InpData%DTctrl   .NE. 0.01_DbKi ) call SetErrStat( ErrID_Fatal, 'Simulation timestep must be equal to 0.01s for now, CSIM imposed', errStat, errMsg, routineName )
   if ( InpData%NRotOuts >8 ) call SetErrStat( ErrID_Fatal, 'Number of generators must be less than 8', errStat, errMsg, routineName )
   if ( (InpData%OutSwtch   < 1) .or. (InpData%OutSwtch   > 3) ) call SetErrStat( ErrID_Fatal, 'OutSwtch must be set to 1=KiteAeroDyn.out, 2=GlueCode.out, 3=both files', errStat, errMsg, routineName )
   
   
   ! TODO: Decide what we will check in terms of the node coordinates and viability of component geometry
   
   end subroutine ValidateInitData
   
end module KiteFastController
