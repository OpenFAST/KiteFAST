!STARTOFREGISTRYGENERATEDFILE 'ActuatorDisk_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! ActuatorDisk_Types
!.................................................................................................................................
! This file is part of ActuatorDisk.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in ActuatorDisk. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE ActuatorDisk_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  ActDsk_InitData  =======
  TYPE, PUBLIC :: ActDsk_InitData
    INTEGER(IntKi)  :: numRtSpd      !< Number of rotor speeds in tables  [-]
    INTEGER(IntKi)  :: numSkew      !< Number of rotor inflow-skew angles in tables [-]
    INTEGER(IntKi)  :: numPitch      !< Number of rotor-collective blade-pitch angles in tables [-]
    INTEGER(IntKi)  :: numVrel      !< Number of inflow velocities in tables [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RtSpds      !< Rotor speeds in tables [rad/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Skews      !< Inflow-skew angles in tables [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Pitches      !< Rotor-collective blade-pitch angles in tables [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Vrels      !< Inflow velocities in tables [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:,:), ALLOCATABLE  :: RtSpd_Ptch_Vrel_Skw_Table      !< Table of force/moment/power coefficients [-]
  END TYPE ActDsk_InitData
! =======================
! =========  ActDsk_InitInputType  =======
  TYPE, PUBLIC :: ActDsk_InitInputType
    CHARACTER(1024)  :: FileName      !< Supplied by Driver:  The name of the root file including the full path [-]
    REAL(ReKi)  :: AirDens      !< Air density [kg/m^3]
    REAL(ReKi)  :: R      !< Supplied by Driver:  Rotor radius [m]
    TYPE(ActDsk_InitData)  :: InitInpFile      !< Initialization input data read from input file [-]
    INTEGER(IntKi)  :: RotorMod      !< Rotor calculation model (-) (switch) {0:none, 1:actuator disk} [-]
  END TYPE ActDsk_InitInputType
! =======================
! =========  ActDsk_InitOutputType  =======
  TYPE, PUBLIC :: ActDsk_InitOutputType
    TYPE(ProgDesc)  :: Version      !< Version structure [-]
  END TYPE ActDsk_InitOutputType
! =======================
! =========  ActDsk_ContinuousStateType  =======
  TYPE, PUBLIC :: ActDsk_ContinuousStateType
    REAL(ReKi)  :: DummyContState      !< Remove this variable if you have continuous states [-]
  END TYPE ActDsk_ContinuousStateType
! =======================
! =========  ActDsk_DiscreteStateType  =======
  TYPE, PUBLIC :: ActDsk_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      !< Remove this variable if you have discrete states [-]
  END TYPE ActDsk_DiscreteStateType
! =======================
! =========  ActDsk_ConstraintStateType  =======
  TYPE, PUBLIC :: ActDsk_ConstraintStateType
    REAL(ReKi)  :: DummyConstraintState      !< Remove this variable if you have contraint states [-]
  END TYPE ActDsk_ConstraintStateType
! =======================
! =========  ActDsk_OtherStateType  =======
  TYPE, PUBLIC :: ActDsk_OtherStateType
    REAL(ReKi)  :: DummyOtherState      !< Remove this variable if you have other states [-]
  END TYPE ActDsk_OtherStateType
! =======================
! =========  ActDsk_MiscVarType  =======
  TYPE, PUBLIC :: ActDsk_MiscVarType
    REAL(ReKi)  :: Cp      !< Power coefficient [-]
    REAL(ReKi)  :: Ct      !< Thrust coefficient [-]
    REAL(ReKi)  :: Cq      !< Torque coefficient [-]
    REAL(ReKi)  :: TSR      !< Tip speed ratio [-]
  END TYPE ActDsk_MiscVarType
! =======================
! =========  ActDsk_ParameterType  =======
  TYPE, PUBLIC :: ActDsk_ParameterType
    REAL(ReKi)  :: R      !< Rotor radius [m]
    REAL(ReKi)  :: D      !< Rotor diameter [m]
    INTEGER(IntKi)  :: RotorMod      !< Rotor calculation model (-) (switch) {0:none, 1:actuator disk} [-]
    REAL(ReKi)  :: RhoD4      !< air density times rotor diameter^4 [kg-m]
    INTEGER(IntKi)  :: numRtSpd      !< Number of rotor speeds in tables  [-]
    INTEGER(IntKi)  :: numSkew      !< Number of rotor inflow-skew angles in tables [-]
    INTEGER(IntKi)  :: numVrel      !< Number of inflow velocities in tables [-]
    INTEGER(IntKi)  :: numPitch      !< Number of rotor-collective blade-pitch angles in tables [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RtSpds      !< Rotor speed in tables [rad/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Skews      !< Rotor inflow-skew angles in tables [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Pitches      !< Rotor inflow-skew angles in tables [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Vrels      !< Inflow velocities in tables [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:,:), ALLOCATABLE  :: RtSpd_Ptch_Vrel_Skw_Table      !< Table of force/moment/power coefficients [-]
  END TYPE ActDsk_ParameterType
! =======================
! =========  ActDsk_InputType  =======
  TYPE, PUBLIC :: ActDsk_InputType
    REAL(ReKi)  :: RtSpd      !< Rotor speed [rad/s]
    REAL(ReKi)  :: DiskAve_Vrel      !< Rotor-disk-averaged relative wind speed (ambient + kite motion) [m/s]
    REAL(ReKi)  :: skew      !< Rotor inflow-skew angle [rad]
    REAL(ReKi)  :: pitch      !< Rotor-collective blade-pitch angle [rad]
  END TYPE ActDsk_InputType
! =======================
! =========  ActDsk_OutputType  =======
  TYPE, PUBLIC :: ActDsk_OutputType
    REAL(ReKi)  :: Fx      !< Thrust (x/axial) force [N]
    REAL(ReKi)  :: Fy      !< Transverse (y) force [N]
    REAL(ReKi)  :: Fz      !< Transverse (z) force [N]
    REAL(ReKi)  :: Mx      !< Torque (x) [Nm]
    REAL(ReKi)  :: My      !< Transverse (y) moment [Nm]
    REAL(ReKi)  :: Mz      !< Transverse (z) moment [Nm]
    REAL(ReKi)  :: P      !< Electrical power [W]
  END TYPE ActDsk_OutputType
! =======================
CONTAINS
 SUBROUTINE ActDsk_CopyInitData( SrcInitDataData, DstInitDataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ActDsk_InitData), INTENT(IN) :: SrcInitDataData
   TYPE(ActDsk_InitData), INTENT(INOUT) :: DstInitDataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_CopyInitData'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitDataData%numRtSpd = SrcInitDataData%numRtSpd
    DstInitDataData%numSkew = SrcInitDataData%numSkew
    DstInitDataData%numPitch = SrcInitDataData%numPitch
    DstInitDataData%numVrel = SrcInitDataData%numVrel
IF (ALLOCATED(SrcInitDataData%RtSpds)) THEN
  i1_l = LBOUND(SrcInitDataData%RtSpds,1)
  i1_u = UBOUND(SrcInitDataData%RtSpds,1)
  IF (.NOT. ALLOCATED(DstInitDataData%RtSpds)) THEN 
    ALLOCATE(DstInitDataData%RtSpds(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitDataData%RtSpds.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitDataData%RtSpds = SrcInitDataData%RtSpds
ENDIF
IF (ALLOCATED(SrcInitDataData%Skews)) THEN
  i1_l = LBOUND(SrcInitDataData%Skews,1)
  i1_u = UBOUND(SrcInitDataData%Skews,1)
  IF (.NOT. ALLOCATED(DstInitDataData%Skews)) THEN 
    ALLOCATE(DstInitDataData%Skews(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitDataData%Skews.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitDataData%Skews = SrcInitDataData%Skews
ENDIF
IF (ALLOCATED(SrcInitDataData%Pitches)) THEN
  i1_l = LBOUND(SrcInitDataData%Pitches,1)
  i1_u = UBOUND(SrcInitDataData%Pitches,1)
  IF (.NOT. ALLOCATED(DstInitDataData%Pitches)) THEN 
    ALLOCATE(DstInitDataData%Pitches(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitDataData%Pitches.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitDataData%Pitches = SrcInitDataData%Pitches
ENDIF
IF (ALLOCATED(SrcInitDataData%Vrels)) THEN
  i1_l = LBOUND(SrcInitDataData%Vrels,1)
  i1_u = UBOUND(SrcInitDataData%Vrels,1)
  IF (.NOT. ALLOCATED(DstInitDataData%Vrels)) THEN 
    ALLOCATE(DstInitDataData%Vrels(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitDataData%Vrels.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitDataData%Vrels = SrcInitDataData%Vrels
ENDIF
IF (ALLOCATED(SrcInitDataData%RtSpd_Ptch_Vrel_Skw_Table)) THEN
  i1_l = LBOUND(SrcInitDataData%RtSpd_Ptch_Vrel_Skw_Table,1)
  i1_u = UBOUND(SrcInitDataData%RtSpd_Ptch_Vrel_Skw_Table,1)
  i2_l = LBOUND(SrcInitDataData%RtSpd_Ptch_Vrel_Skw_Table,2)
  i2_u = UBOUND(SrcInitDataData%RtSpd_Ptch_Vrel_Skw_Table,2)
  i3_l = LBOUND(SrcInitDataData%RtSpd_Ptch_Vrel_Skw_Table,3)
  i3_u = UBOUND(SrcInitDataData%RtSpd_Ptch_Vrel_Skw_Table,3)
  i4_l = LBOUND(SrcInitDataData%RtSpd_Ptch_Vrel_Skw_Table,4)
  i4_u = UBOUND(SrcInitDataData%RtSpd_Ptch_Vrel_Skw_Table,4)
  i5_l = LBOUND(SrcInitDataData%RtSpd_Ptch_Vrel_Skw_Table,5)
  i5_u = UBOUND(SrcInitDataData%RtSpd_Ptch_Vrel_Skw_Table,5)
  IF (.NOT. ALLOCATED(DstInitDataData%RtSpd_Ptch_Vrel_Skw_Table)) THEN 
    ALLOCATE(DstInitDataData%RtSpd_Ptch_Vrel_Skw_Table(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u,i5_l:i5_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitDataData%RtSpd_Ptch_Vrel_Skw_Table.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitDataData%RtSpd_Ptch_Vrel_Skw_Table = SrcInitDataData%RtSpd_Ptch_Vrel_Skw_Table
ENDIF
 END SUBROUTINE ActDsk_CopyInitData

 SUBROUTINE ActDsk_DestroyInitData( InitDataData, ErrStat, ErrMsg )
  TYPE(ActDsk_InitData), INTENT(INOUT) :: InitDataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'ActDsk_DestroyInitData'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitDataData%RtSpds)) THEN
  DEALLOCATE(InitDataData%RtSpds)
ENDIF
IF (ALLOCATED(InitDataData%Skews)) THEN
  DEALLOCATE(InitDataData%Skews)
ENDIF
IF (ALLOCATED(InitDataData%Pitches)) THEN
  DEALLOCATE(InitDataData%Pitches)
ENDIF
IF (ALLOCATED(InitDataData%Vrels)) THEN
  DEALLOCATE(InitDataData%Vrels)
ENDIF
IF (ALLOCATED(InitDataData%RtSpd_Ptch_Vrel_Skw_Table)) THEN
  DEALLOCATE(InitDataData%RtSpd_Ptch_Vrel_Skw_Table)
ENDIF
 END SUBROUTINE ActDsk_DestroyInitData

 SUBROUTINE ActDsk_PackInitData( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ActDsk_InitData),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_PackInitData'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! numRtSpd
      Int_BufSz  = Int_BufSz  + 1  ! numSkew
      Int_BufSz  = Int_BufSz  + 1  ! numPitch
      Int_BufSz  = Int_BufSz  + 1  ! numVrel
  Int_BufSz   = Int_BufSz   + 1     ! RtSpds allocated yes/no
  IF ( ALLOCATED(InData%RtSpds) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! RtSpds upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%RtSpds)  ! RtSpds
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Skews allocated yes/no
  IF ( ALLOCATED(InData%Skews) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Skews upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Skews)  ! Skews
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Pitches allocated yes/no
  IF ( ALLOCATED(InData%Pitches) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Pitches upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Pitches)  ! Pitches
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vrels allocated yes/no
  IF ( ALLOCATED(InData%Vrels) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Vrels upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vrels)  ! Vrels
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! RtSpd_Ptch_Vrel_Skw_Table allocated yes/no
  IF ( ALLOCATED(InData%RtSpd_Ptch_Vrel_Skw_Table) ) THEN
    Int_BufSz   = Int_BufSz   + 2*5  ! RtSpd_Ptch_Vrel_Skw_Table upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%RtSpd_Ptch_Vrel_Skw_Table)  ! RtSpd_Ptch_Vrel_Skw_Table
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%numRtSpd
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%numSkew
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%numPitch
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%numVrel
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%RtSpds) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RtSpds,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RtSpds,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%RtSpds,1), UBOUND(InData%RtSpds,1)
        ReKiBuf(Re_Xferred) = InData%RtSpds(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Skews) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Skews,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Skews,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Skews,1), UBOUND(InData%Skews,1)
        ReKiBuf(Re_Xferred) = InData%Skews(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Pitches) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Pitches,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Pitches,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Pitches,1), UBOUND(InData%Pitches,1)
        ReKiBuf(Re_Xferred) = InData%Pitches(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Vrels) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vrels,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vrels,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Vrels,1), UBOUND(InData%Vrels,1)
        ReKiBuf(Re_Xferred) = InData%Vrels(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%RtSpd_Ptch_Vrel_Skw_Table) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,4)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,5)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,5)
    Int_Xferred = Int_Xferred + 2

      DO i5 = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,5), UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,5)
        DO i4 = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,4), UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,4)
          DO i3 = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,3), UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,3)
            DO i2 = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,2), UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,2)
              DO i1 = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,1), UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,1)
                ReKiBuf(Re_Xferred) = InData%RtSpd_Ptch_Vrel_Skw_Table(i1,i2,i3,i4,i5)
                Re_Xferred = Re_Xferred + 1
              END DO
            END DO
          END DO
        END DO
      END DO
  END IF
 END SUBROUTINE ActDsk_PackInitData

 SUBROUTINE ActDsk_UnPackInitData( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ActDsk_InitData), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_UnPackInitData'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%numRtSpd = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%numSkew = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%numPitch = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%numVrel = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RtSpds not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RtSpds)) DEALLOCATE(OutData%RtSpds)
    ALLOCATE(OutData%RtSpds(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RtSpds.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%RtSpds,1), UBOUND(OutData%RtSpds,1)
        OutData%RtSpds(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Skews not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Skews)) DEALLOCATE(OutData%Skews)
    ALLOCATE(OutData%Skews(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Skews.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Skews,1), UBOUND(OutData%Skews,1)
        OutData%Skews(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Pitches not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Pitches)) DEALLOCATE(OutData%Pitches)
    ALLOCATE(OutData%Pitches(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Pitches.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Pitches,1), UBOUND(OutData%Pitches,1)
        OutData%Pitches(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vrels not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vrels)) DEALLOCATE(OutData%Vrels)
    ALLOCATE(OutData%Vrels(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vrels.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Vrels,1), UBOUND(OutData%Vrels,1)
        OutData%Vrels(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RtSpd_Ptch_Vrel_Skw_Table not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i5_l = IntKiBuf( Int_Xferred    )
    i5_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RtSpd_Ptch_Vrel_Skw_Table)) DEALLOCATE(OutData%RtSpd_Ptch_Vrel_Skw_Table)
    ALLOCATE(OutData%RtSpd_Ptch_Vrel_Skw_Table(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u,i5_l:i5_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RtSpd_Ptch_Vrel_Skw_Table.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i5 = LBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,5), UBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,5)
        DO i4 = LBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,4), UBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,4)
          DO i3 = LBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,3), UBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,3)
            DO i2 = LBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,2), UBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,2)
              DO i1 = LBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,1), UBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,1)
                OutData%RtSpd_Ptch_Vrel_Skw_Table(i1,i2,i3,i4,i5) = ReKiBuf(Re_Xferred)
                Re_Xferred = Re_Xferred + 1
              END DO
            END DO
          END DO
        END DO
      END DO
  END IF
 END SUBROUTINE ActDsk_UnPackInitData

 SUBROUTINE ActDsk_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ActDsk_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(ActDsk_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%FileName = SrcInitInputData%FileName
    DstInitInputData%AirDens = SrcInitInputData%AirDens
    DstInitInputData%R = SrcInitInputData%R
      CALL ActDsk_Copyinitdata( SrcInitInputData%InitInpFile, DstInitInputData%InitInpFile, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%RotorMod = SrcInitInputData%RotorMod
 END SUBROUTINE ActDsk_CopyInitInput

 SUBROUTINE ActDsk_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(ActDsk_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'ActDsk_DestroyInitInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL ActDsk_Destroyinitdata( InitInputData%InitInpFile, ErrStat, ErrMsg )
 END SUBROUTINE ActDsk_DestroyInitInput

 SUBROUTINE ActDsk_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ActDsk_InitInputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_PackInitInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%FileName)  ! FileName
      Re_BufSz   = Re_BufSz   + 1  ! AirDens
      Re_BufSz   = Re_BufSz   + 1  ! R
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! InitInpFile: size of buffers for each call to pack subtype
      CALL ActDsk_Packinitdata( Re_Buf, Db_Buf, Int_Buf, InData%InitInpFile, ErrStat2, ErrMsg2, .TRUE. ) ! InitInpFile 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! InitInpFile
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! InitInpFile
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! InitInpFile
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz  = Int_BufSz  + 1  ! RotorMod
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    DO I = 1, LEN(InData%FileName)
      IntKiBuf(Int_Xferred) = ICHAR(InData%FileName(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    ReKiBuf(Re_Xferred) = InData%AirDens
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%R
    Re_Xferred = Re_Xferred + 1
      CALL ActDsk_Packinitdata( Re_Buf, Db_Buf, Int_Buf, InData%InitInpFile, ErrStat2, ErrMsg2, OnlySize ) ! InitInpFile 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    IntKiBuf(Int_Xferred) = InData%RotorMod
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE ActDsk_PackInitInput

 SUBROUTINE ActDsk_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ActDsk_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_UnPackInitInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    DO I = 1, LEN(OutData%FileName)
      OutData%FileName(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%AirDens = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%R = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL ActDsk_Unpackinitdata( Re_Buf, Db_Buf, Int_Buf, OutData%InitInpFile, ErrStat2, ErrMsg2 ) ! InitInpFile 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    OutData%RotorMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE ActDsk_UnPackInitInput

 SUBROUTINE ActDsk_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ActDsk_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(ActDsk_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Version, DstInitOutputData%Version, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE ActDsk_CopyInitOutput

 SUBROUTINE ActDsk_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(ActDsk_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'ActDsk_DestroyInitOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Version, ErrStat, ErrMsg )
 END SUBROUTINE ActDsk_DestroyInitOutput

 SUBROUTINE ActDsk_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ActDsk_InitOutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_PackInitOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! Version: size of buffers for each call to pack subtype
      CALL NWTC_Library_Packprogdesc( Re_Buf, Db_Buf, Int_Buf, InData%Version, ErrStat2, ErrMsg2, .TRUE. ) ! Version 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Version
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Version
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Version
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL NWTC_Library_Packprogdesc( Re_Buf, Db_Buf, Int_Buf, InData%Version, ErrStat2, ErrMsg2, OnlySize ) ! Version 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE ActDsk_PackInitOutput

 SUBROUTINE ActDsk_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ActDsk_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_UnPackInitOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL NWTC_Library_Unpackprogdesc( Re_Buf, Db_Buf, Int_Buf, OutData%Version, ErrStat2, ErrMsg2 ) ! Version 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE ActDsk_UnPackInitOutput

 SUBROUTINE ActDsk_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ActDsk_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(ActDsk_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstContStateData%DummyContState = SrcContStateData%DummyContState
 END SUBROUTINE ActDsk_CopyContState

 SUBROUTINE ActDsk_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(ActDsk_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'ActDsk_DestroyContState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE ActDsk_DestroyContState

 SUBROUTINE ActDsk_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ActDsk_ContinuousStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_PackContState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! DummyContState
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%DummyContState
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_PackContState

 SUBROUTINE ActDsk_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ActDsk_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_UnPackContState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyContState = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_UnPackContState

 SUBROUTINE ActDsk_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ActDsk_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(ActDsk_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE ActDsk_CopyDiscState

 SUBROUTINE ActDsk_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(ActDsk_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'ActDsk_DestroyDiscState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE ActDsk_DestroyDiscState

 SUBROUTINE ActDsk_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ActDsk_DiscreteStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_PackDiscState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%DummyDiscState
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_PackDiscState

 SUBROUTINE ActDsk_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ActDsk_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_UnPackDiscState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyDiscState = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_UnPackDiscState

 SUBROUTINE ActDsk_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ActDsk_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(ActDsk_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%DummyConstraintState = SrcConstrStateData%DummyConstraintState
 END SUBROUTINE ActDsk_CopyConstrState

 SUBROUTINE ActDsk_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(ActDsk_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'ActDsk_DestroyConstrState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE ActDsk_DestroyConstrState

 SUBROUTINE ActDsk_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ActDsk_ConstraintStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_PackConstrState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! DummyConstraintState
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%DummyConstraintState
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_PackConstrState

 SUBROUTINE ActDsk_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ActDsk_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_UnPackConstrState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyConstraintState = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_UnPackConstrState

 SUBROUTINE ActDsk_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ActDsk_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(ActDsk_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOtherStateData%DummyOtherState = SrcOtherStateData%DummyOtherState
 END SUBROUTINE ActDsk_CopyOtherState

 SUBROUTINE ActDsk_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(ActDsk_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'ActDsk_DestroyOtherState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE ActDsk_DestroyOtherState

 SUBROUTINE ActDsk_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ActDsk_OtherStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_PackOtherState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! DummyOtherState
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%DummyOtherState
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_PackOtherState

 SUBROUTINE ActDsk_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ActDsk_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_UnPackOtherState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%DummyOtherState = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_UnPackOtherState

 SUBROUTINE ActDsk_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ActDsk_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(ActDsk_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMiscData%Cp = SrcMiscData%Cp
    DstMiscData%Ct = SrcMiscData%Ct
    DstMiscData%Cq = SrcMiscData%Cq
    DstMiscData%TSR = SrcMiscData%TSR
 END SUBROUTINE ActDsk_CopyMisc

 SUBROUTINE ActDsk_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(ActDsk_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'ActDsk_DestroyMisc'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE ActDsk_DestroyMisc

 SUBROUTINE ActDsk_PackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ActDsk_MiscVarType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_PackMisc'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! Cp
      Re_BufSz   = Re_BufSz   + 1  ! Ct
      Re_BufSz   = Re_BufSz   + 1  ! Cq
      Re_BufSz   = Re_BufSz   + 1  ! TSR
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%Cp
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Ct
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Cq
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%TSR
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_PackMisc

 SUBROUTINE ActDsk_UnPackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ActDsk_MiscVarType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_UnPackMisc'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%Cp = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Ct = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Cq = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%TSR = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_UnPackMisc

 SUBROUTINE ActDsk_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ActDsk_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(ActDsk_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%R = SrcParamData%R
    DstParamData%D = SrcParamData%D
    DstParamData%RotorMod = SrcParamData%RotorMod
    DstParamData%RhoD4 = SrcParamData%RhoD4
    DstParamData%numRtSpd = SrcParamData%numRtSpd
    DstParamData%numSkew = SrcParamData%numSkew
    DstParamData%numVrel = SrcParamData%numVrel
    DstParamData%numPitch = SrcParamData%numPitch
IF (ALLOCATED(SrcParamData%RtSpds)) THEN
  i1_l = LBOUND(SrcParamData%RtSpds,1)
  i1_u = UBOUND(SrcParamData%RtSpds,1)
  IF (.NOT. ALLOCATED(DstParamData%RtSpds)) THEN 
    ALLOCATE(DstParamData%RtSpds(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%RtSpds.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%RtSpds = SrcParamData%RtSpds
ENDIF
IF (ALLOCATED(SrcParamData%Skews)) THEN
  i1_l = LBOUND(SrcParamData%Skews,1)
  i1_u = UBOUND(SrcParamData%Skews,1)
  IF (.NOT. ALLOCATED(DstParamData%Skews)) THEN 
    ALLOCATE(DstParamData%Skews(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Skews.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Skews = SrcParamData%Skews
ENDIF
IF (ALLOCATED(SrcParamData%Pitches)) THEN
  i1_l = LBOUND(SrcParamData%Pitches,1)
  i1_u = UBOUND(SrcParamData%Pitches,1)
  IF (.NOT. ALLOCATED(DstParamData%Pitches)) THEN 
    ALLOCATE(DstParamData%Pitches(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Pitches.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Pitches = SrcParamData%Pitches
ENDIF
IF (ALLOCATED(SrcParamData%Vrels)) THEN
  i1_l = LBOUND(SrcParamData%Vrels,1)
  i1_u = UBOUND(SrcParamData%Vrels,1)
  IF (.NOT. ALLOCATED(DstParamData%Vrels)) THEN 
    ALLOCATE(DstParamData%Vrels(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Vrels.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Vrels = SrcParamData%Vrels
ENDIF
IF (ALLOCATED(SrcParamData%RtSpd_Ptch_Vrel_Skw_Table)) THEN
  i1_l = LBOUND(SrcParamData%RtSpd_Ptch_Vrel_Skw_Table,1)
  i1_u = UBOUND(SrcParamData%RtSpd_Ptch_Vrel_Skw_Table,1)
  i2_l = LBOUND(SrcParamData%RtSpd_Ptch_Vrel_Skw_Table,2)
  i2_u = UBOUND(SrcParamData%RtSpd_Ptch_Vrel_Skw_Table,2)
  i3_l = LBOUND(SrcParamData%RtSpd_Ptch_Vrel_Skw_Table,3)
  i3_u = UBOUND(SrcParamData%RtSpd_Ptch_Vrel_Skw_Table,3)
  i4_l = LBOUND(SrcParamData%RtSpd_Ptch_Vrel_Skw_Table,4)
  i4_u = UBOUND(SrcParamData%RtSpd_Ptch_Vrel_Skw_Table,4)
  i5_l = LBOUND(SrcParamData%RtSpd_Ptch_Vrel_Skw_Table,5)
  i5_u = UBOUND(SrcParamData%RtSpd_Ptch_Vrel_Skw_Table,5)
  IF (.NOT. ALLOCATED(DstParamData%RtSpd_Ptch_Vrel_Skw_Table)) THEN 
    ALLOCATE(DstParamData%RtSpd_Ptch_Vrel_Skw_Table(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u,i5_l:i5_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%RtSpd_Ptch_Vrel_Skw_Table.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%RtSpd_Ptch_Vrel_Skw_Table = SrcParamData%RtSpd_Ptch_Vrel_Skw_Table
ENDIF
 END SUBROUTINE ActDsk_CopyParam

 SUBROUTINE ActDsk_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(ActDsk_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'ActDsk_DestroyParam'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%RtSpds)) THEN
  DEALLOCATE(ParamData%RtSpds)
ENDIF
IF (ALLOCATED(ParamData%Skews)) THEN
  DEALLOCATE(ParamData%Skews)
ENDIF
IF (ALLOCATED(ParamData%Pitches)) THEN
  DEALLOCATE(ParamData%Pitches)
ENDIF
IF (ALLOCATED(ParamData%Vrels)) THEN
  DEALLOCATE(ParamData%Vrels)
ENDIF
IF (ALLOCATED(ParamData%RtSpd_Ptch_Vrel_Skw_Table)) THEN
  DEALLOCATE(ParamData%RtSpd_Ptch_Vrel_Skw_Table)
ENDIF
 END SUBROUTINE ActDsk_DestroyParam

 SUBROUTINE ActDsk_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ActDsk_ParameterType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_PackParam'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! R
      Re_BufSz   = Re_BufSz   + 1  ! D
      Int_BufSz  = Int_BufSz  + 1  ! RotorMod
      Re_BufSz   = Re_BufSz   + 1  ! RhoD4
      Int_BufSz  = Int_BufSz  + 1  ! numRtSpd
      Int_BufSz  = Int_BufSz  + 1  ! numSkew
      Int_BufSz  = Int_BufSz  + 1  ! numVrel
      Int_BufSz  = Int_BufSz  + 1  ! numPitch
  Int_BufSz   = Int_BufSz   + 1     ! RtSpds allocated yes/no
  IF ( ALLOCATED(InData%RtSpds) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! RtSpds upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%RtSpds)  ! RtSpds
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Skews allocated yes/no
  IF ( ALLOCATED(InData%Skews) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Skews upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Skews)  ! Skews
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Pitches allocated yes/no
  IF ( ALLOCATED(InData%Pitches) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Pitches upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Pitches)  ! Pitches
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vrels allocated yes/no
  IF ( ALLOCATED(InData%Vrels) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Vrels upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vrels)  ! Vrels
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! RtSpd_Ptch_Vrel_Skw_Table allocated yes/no
  IF ( ALLOCATED(InData%RtSpd_Ptch_Vrel_Skw_Table) ) THEN
    Int_BufSz   = Int_BufSz   + 2*5  ! RtSpd_Ptch_Vrel_Skw_Table upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%RtSpd_Ptch_Vrel_Skw_Table)  ! RtSpd_Ptch_Vrel_Skw_Table
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%R
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%D
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%RotorMod
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%RhoD4
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%numRtSpd
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%numSkew
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%numVrel
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%numPitch
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%RtSpds) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RtSpds,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RtSpds,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%RtSpds,1), UBOUND(InData%RtSpds,1)
        ReKiBuf(Re_Xferred) = InData%RtSpds(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Skews) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Skews,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Skews,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Skews,1), UBOUND(InData%Skews,1)
        ReKiBuf(Re_Xferred) = InData%Skews(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Pitches) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Pitches,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Pitches,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Pitches,1), UBOUND(InData%Pitches,1)
        ReKiBuf(Re_Xferred) = InData%Pitches(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Vrels) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vrels,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vrels,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Vrels,1), UBOUND(InData%Vrels,1)
        ReKiBuf(Re_Xferred) = InData%Vrels(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%RtSpd_Ptch_Vrel_Skw_Table) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,4)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,5)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,5)
    Int_Xferred = Int_Xferred + 2

      DO i5 = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,5), UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,5)
        DO i4 = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,4), UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,4)
          DO i3 = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,3), UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,3)
            DO i2 = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,2), UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,2)
              DO i1 = LBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,1), UBOUND(InData%RtSpd_Ptch_Vrel_Skw_Table,1)
                ReKiBuf(Re_Xferred) = InData%RtSpd_Ptch_Vrel_Skw_Table(i1,i2,i3,i4,i5)
                Re_Xferred = Re_Xferred + 1
              END DO
            END DO
          END DO
        END DO
      END DO
  END IF
 END SUBROUTINE ActDsk_PackParam

 SUBROUTINE ActDsk_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ActDsk_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_UnPackParam'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%R = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%D = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%RotorMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%RhoD4 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%numRtSpd = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%numSkew = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%numVrel = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%numPitch = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RtSpds not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RtSpds)) DEALLOCATE(OutData%RtSpds)
    ALLOCATE(OutData%RtSpds(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RtSpds.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%RtSpds,1), UBOUND(OutData%RtSpds,1)
        OutData%RtSpds(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Skews not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Skews)) DEALLOCATE(OutData%Skews)
    ALLOCATE(OutData%Skews(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Skews.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Skews,1), UBOUND(OutData%Skews,1)
        OutData%Skews(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Pitches not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Pitches)) DEALLOCATE(OutData%Pitches)
    ALLOCATE(OutData%Pitches(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Pitches.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Pitches,1), UBOUND(OutData%Pitches,1)
        OutData%Pitches(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vrels not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vrels)) DEALLOCATE(OutData%Vrels)
    ALLOCATE(OutData%Vrels(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vrels.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Vrels,1), UBOUND(OutData%Vrels,1)
        OutData%Vrels(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RtSpd_Ptch_Vrel_Skw_Table not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i5_l = IntKiBuf( Int_Xferred    )
    i5_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RtSpd_Ptch_Vrel_Skw_Table)) DEALLOCATE(OutData%RtSpd_Ptch_Vrel_Skw_Table)
    ALLOCATE(OutData%RtSpd_Ptch_Vrel_Skw_Table(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u,i5_l:i5_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RtSpd_Ptch_Vrel_Skw_Table.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i5 = LBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,5), UBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,5)
        DO i4 = LBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,4), UBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,4)
          DO i3 = LBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,3), UBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,3)
            DO i2 = LBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,2), UBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,2)
              DO i1 = LBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,1), UBOUND(OutData%RtSpd_Ptch_Vrel_Skw_Table,1)
                OutData%RtSpd_Ptch_Vrel_Skw_Table(i1,i2,i3,i4,i5) = ReKiBuf(Re_Xferred)
                Re_Xferred = Re_Xferred + 1
              END DO
            END DO
          END DO
        END DO
      END DO
  END IF
 END SUBROUTINE ActDsk_UnPackParam

 SUBROUTINE ActDsk_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ActDsk_InputType), INTENT(IN) :: SrcInputData
   TYPE(ActDsk_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputData%RtSpd = SrcInputData%RtSpd
    DstInputData%DiskAve_Vrel = SrcInputData%DiskAve_Vrel
    DstInputData%skew = SrcInputData%skew
    DstInputData%pitch = SrcInputData%pitch
 END SUBROUTINE ActDsk_CopyInput

 SUBROUTINE ActDsk_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(ActDsk_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'ActDsk_DestroyInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE ActDsk_DestroyInput

 SUBROUTINE ActDsk_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ActDsk_InputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_PackInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! RtSpd
      Re_BufSz   = Re_BufSz   + 1  ! DiskAve_Vrel
      Re_BufSz   = Re_BufSz   + 1  ! skew
      Re_BufSz   = Re_BufSz   + 1  ! pitch
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%RtSpd
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%DiskAve_Vrel
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%skew
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%pitch
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_PackInput

 SUBROUTINE ActDsk_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ActDsk_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_UnPackInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%RtSpd = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DiskAve_Vrel = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%skew = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%pitch = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_UnPackInput

 SUBROUTINE ActDsk_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ActDsk_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(ActDsk_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOutputData%Fx = SrcOutputData%Fx
    DstOutputData%Fy = SrcOutputData%Fy
    DstOutputData%Fz = SrcOutputData%Fz
    DstOutputData%Mx = SrcOutputData%Mx
    DstOutputData%My = SrcOutputData%My
    DstOutputData%Mz = SrcOutputData%Mz
    DstOutputData%P = SrcOutputData%P
 END SUBROUTINE ActDsk_CopyOutput

 SUBROUTINE ActDsk_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(ActDsk_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'ActDsk_DestroyOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE ActDsk_DestroyOutput

 SUBROUTINE ActDsk_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ActDsk_OutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_PackOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! Fx
      Re_BufSz   = Re_BufSz   + 1  ! Fy
      Re_BufSz   = Re_BufSz   + 1  ! Fz
      Re_BufSz   = Re_BufSz   + 1  ! Mx
      Re_BufSz   = Re_BufSz   + 1  ! My
      Re_BufSz   = Re_BufSz   + 1  ! Mz
      Re_BufSz   = Re_BufSz   + 1  ! P
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%Fx
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Fy
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Fz
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Mx
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%My
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Mz
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%P
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_PackOutput

 SUBROUTINE ActDsk_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ActDsk_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ActDsk_UnPackOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%Fx = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Fy = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Fz = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Mx = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%My = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Mz = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%P = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE ActDsk_UnPackOutput

END MODULE ActuatorDisk_Types
!ENDOFREGISTRYGENERATEDFILE
