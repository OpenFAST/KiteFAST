!**********************************************************************************************************************************
! LICENSING
! Copyright (C) 2018  National Renewable Energy Laboratory
!
!    This file is part of OpenFAST.
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!**********************************************************************************************************************************
!> This module sets up the output-handling data structures for KiteAeroDyn.
   
module KiteFAST_OS_IO
   
   use NWTC_Library
   use KiteFAST_OS_Types
   
   implicit none
   
! ===================================================================================================
! This code was generated by Write_ChckOutLst.m at 15-May-2019 09:33:09.


     ! Parameters related to output length (number of characters allowed in the output data headers):

   INTEGER(IntKi), PARAMETER      :: OutStrLenM1 = ChanLen - 1


     ! Indices for computing output channels:
     ! NOTES: 
     !    (1) These parameters are in the order stored in "OutListParameters.xlsx"
     !    (2) Array AllOuts() must be dimensioned to the value of the largest output parameter

     !  Time: 

   INTEGER(IntKi), PARAMETER      :: Time      =  0


     ! Floating Platform (Buoy):

   INTEGER(IntKi), PARAMETER      :: BuoySurge =  1
   INTEGER(IntKi), PARAMETER      :: BuoySway  =  2
   INTEGER(IntKi), PARAMETER      :: BuoyHeave =  3
   INTEGER(IntKi), PARAMETER      :: BuoyRoll  =  4
   INTEGER(IntKi), PARAMETER      :: BuoyPitch =  5
   INTEGER(IntKi), PARAMETER      :: BuoyYaw   =  6
   INTEGER(IntKi), PARAMETER      :: BuoyTVx   =  7
   INTEGER(IntKi), PARAMETER      :: BuoyTVy   =  8
   INTEGER(IntKi), PARAMETER      :: BuoyTVz   =  9
   INTEGER(IntKi), PARAMETER      :: BuoyRVx   = 10
   INTEGER(IntKi), PARAMETER      :: BuoyRVy   = 11
   INTEGER(IntKi), PARAMETER      :: BuoyRVz   = 12
   INTEGER(IntKi), PARAMETER      :: BuoyTAx   = 13
   INTEGER(IntKi), PARAMETER      :: BuoyTAy   = 14
   INTEGER(IntKi), PARAMETER      :: BuoyTAz   = 15
   INTEGER(IntKi), PARAMETER      :: BIMUPxi   = 16
   INTEGER(IntKi), PARAMETER      :: BIMUPyi   = 17
   INTEGER(IntKi), PARAMETER      :: BIMUPzi   = 18
   INTEGER(IntKi), PARAMETER      :: BIMURoll  = 19
   INTEGER(IntKi), PARAMETER      :: BIMUPitch = 20
   INTEGER(IntKi), PARAMETER      :: BIMUYaw   = 21
   INTEGER(IntKi), PARAMETER      :: BIMUTVx   = 22
   INTEGER(IntKi), PARAMETER      :: BIMUTVy   = 23
   INTEGER(IntKi), PARAMETER      :: BIMUTVz   = 24
   INTEGER(IntKi), PARAMETER      :: BIMURVx   = 25
   INTEGER(IntKi), PARAMETER      :: BIMURVy   = 26
   INTEGER(IntKi), PARAMETER      :: BIMURVz   = 27
   INTEGER(IntKi), PARAMETER      :: BIMUTAx   = 28
   INTEGER(IntKi), PARAMETER      :: BIMUTAy   = 29
   INTEGER(IntKi), PARAMETER      :: BIMUTAz   = 30
   INTEGER(IntKi), PARAMETER      :: BGSRPxi   = 31
   INTEGER(IntKi), PARAMETER      :: BGSRPyi   = 32
   INTEGER(IntKi), PARAMETER      :: BGSRPzi   = 33
   INTEGER(IntKi), PARAMETER      :: BGSRRoll  = 34
   INTEGER(IntKi), PARAMETER      :: BGSRPitch = 35
   INTEGER(IntKi), PARAMETER      :: BGSRYaw   = 36
   INTEGER(IntKi), PARAMETER      :: BGSRTVx   = 37
   INTEGER(IntKi), PARAMETER      :: BGSRTVy   = 38
   INTEGER(IntKi), PARAMETER      :: BGSRTVz   = 39
   INTEGER(IntKi), PARAMETER      :: BGSRRVx   = 40
   INTEGER(IntKi), PARAMETER      :: BGSRRVy   = 41
   INTEGER(IntKi), PARAMETER      :: BGSRRVz   = 42
   INTEGER(IntKi), PARAMETER      :: BGSRTAx   = 43
   INTEGER(IntKi), PARAMETER      :: BGSRTAy   = 44
   INTEGER(IntKi), PARAMETER      :: BGSRTAz   = 45


     ! The maximum number of output channels which can be output by the code.
   INTEGER(IntKi), PARAMETER      :: MaxOutOSPts = 45
   INTEGER(IntKi), PARAMETER      :: MaxOutFullPts = 4023

!End of code generated by Matlab script
! ===================================================================================================
   contains   
 !recursive subroutine ShiftOutListEntries(j, numOuts, Outlist)  
 !   INTEGER(IntKi),            INTENT(IN)    :: j
 !   INTEGER(IntKi),            INTENT(IN)    :: numOuts
 !   CHARACTER(ChanLen),        INTENT(INOUT) :: OutList(:)                        !< The list out user-requested outputs
 !
 !   
 !  Outlist(j) = Outlist(j+1)
 !  if (j < numOuts) call ShiftOutListEntries(j+1, numOuts, Outlist)
 !  
 !end subroutine ShiftOutListEntries
 !
 ! recursive subroutine ShiftOutParams(j, numOuts, Outlist)  
 !   INTEGER(IntKi),            INTENT(IN)    :: j
 !   INTEGER(IntKi),            INTENT(IN)    :: numOuts
 !   CHARACTER(ChanLen),        INTENT(INOUT) :: OutList(:)                        !< The list out user-requested outputs
 !
 !   
 !  Outlist(j) = Outlist(j+1)
 !  if (j < numOuts) call ShiftOutListEntries(j+1, numOuts, Outlist)
 !  
 ! end subroutine ShiftOutParams
  
 SUBROUTINE KFAST_OS_FindValidParam(OutList, NumOuts, p, numInValidOuts, ErrStat, ErrMsg )
!..................................................................................................................................

   IMPLICIT                        NONE

      ! Passed variables

   CHARACTER(ChanLen),            INTENT(INOUT)  :: OutList(:)          !< The list out user-requested outputs
   INTEGER(IntKi),                INTENT(INOUT)  :: NumOuts             !< Number of KiteFAST-OS level valid outputs
   TYPE(KFAST_OS_ParameterType),  INTENT(INOUT)  :: p                   !< The module parameters
   INTEGER(IntKi),                INTENT(OUT)    :: numInValidOuts      !< Number of invalid outputs
   !CHARACTER(ChanLen),allocatable,INTENT(OUT)    :: newOutList(:)       !< Only the invalid entries in original Outlist
   INTEGER(IntKi),                INTENT(OUT)    :: ErrStat             !< The error status code
   CHARACTER(*),                  INTENT(OUT)    :: ErrMsg              !< The error message, if an error occurred

      ! Local variables

   INTEGER                          :: ErrStat2                             ! temporary (local) error status
   INTEGER                          :: i, ivc, vc                           ! Generic loop-counting index
   INTEGER(IntKi)                   :: numValidOuts        !< Number of valid outputs

   CHARACTER(*), PARAMETER          :: RoutineName = "KFAST_OS_FindValidParam"  
   type(OutParmType),   allocatable :: OutParam(:)
   
      ! Initialize values
   ErrStat = ErrID_None
   ErrMsg = ""
   numValidOuts = NumOuts
   numInvalidOuts = 0
   
   ! Find invalid channels
   do i = 1,NumOuts
      if (p%OutParam(i)%SignM == 0 ) then
         numValidOuts = numValidOuts - 1     
      else
         numInvalidOuts = numInvalidOuts + 1
      end if
      
  end do
 
   if (numValidOuts < NumOuts) then
      
      !allocate(newOutList(numValidOuts), STAT=ErrStat2 )  
      !if ( ErrStat2 /= 0_IntKi )  then
      !   call SetErrStat( ErrID_Fatal,"Error allocating memory for the KiteFAST_OS OutParam array.", ErrStat, ErrMsg, RoutineName )
      !   return
      !endif
      allocate ( OutParam(0:numInvalidOuts) , STAT=ErrStat2 )    
      if ( ErrStat2 /= 0_IntKi )  then
         call SetErrStat( ErrID_Fatal,"Error allocating memory for the KiteFAST_OS OutParam array.", ErrStat, ErrMsg, RoutineName )
         return
      endif
      
      OutParam = p%OutParam
      deallocate(p%OutParam)
      allocate ( p%OutParam(0:numValidOuts) , STAT=ErrStat2 )
      if ( ErrStat2 /= 0_IntKi )  then
         call SetErrStat( ErrID_Fatal,"Error allocating memory for the KiteFAST_OS OutParam array.", ErrStat, ErrMsg, RoutineName )
         return
      endif
      
      vc = 1
      p%OutParam(0) = OutParam(0)
      ivc = 1
      
      do i = 1,NumOuts
         if (p%OutParam(i)%SignM == 0 ) then
            OutList(ivc) = OutList(i)
            ivc = ivc + 1
         else
            p%OutParam(vc) = OutParam(i)
            vc = vc + 1
         end if
      end do
      NumOuts = numValidOuts
   end if
   
end subroutine KFAST_OS_FindValidParam
!**********************************************************************************************************************************
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine checks to see if any requested output channel names (stored in the OutList(:)) are invalid. It returns a 
!! warning if any of the channels are not available outputs from the module.
!!  It assigns the settings for OutParam(:) (i.e, the index, name, and units of the output channels, WriteOutput(:)).
!!  the sign is set to 0 if the channel is invalid.
!! It sets assumes the value p%NumOuts has been set before this routine has been called, and it sets the values of p%OutParam here.
!! 
!! This routine was generated by Write_ChckOutLst.m using the parameters listed in OutListParameters.xlsx at 15-May-2019 09:33:09.
SUBROUTINE KFAST_OS_SetOutParam(OutList, NumOuts, p, ErrStat, ErrMsg )
!..................................................................................................................................

   IMPLICIT                        NONE

      ! Passed variables

   CHARACTER(ChanLen),        INTENT(IN)     :: OutList(:)                        !< The list out user-requested outputs
   INTEGER(IntKi),            INTENT(IN)     :: NumOuts                           !< Number of KFAST-level requested outputs
   TYPE(KFAST_OS_ParameterType),    INTENT(INOUT)  :: p                                 !< The module parameters
   INTEGER(IntKi),            INTENT(OUT)    :: ErrStat                           !< The error status code
   CHARACTER(*),              INTENT(OUT)    :: ErrMsg                            !< The error message, if an error occurred

      ! Local variables

   INTEGER                      :: ErrStat2                                        ! temporary (local) error status
   INTEGER                      :: I                                               ! Generic loop-counting index
   INTEGER                      :: J                                               ! Generic loop-counting index
   INTEGER                      :: INDX                                            ! Index for valid arrays

   LOGICAL                      :: CheckOutListAgain                               ! Flag used to determine if output parameter starting with "M" is valid (or the negative of another parameter)
   LOGICAL                      :: InvalidOutput(0:MaxOutOSPts)                      ! This array determines if the output channel is valid for this configuration
   CHARACTER(ChanLen)           :: OutListTmp                                      ! A string to temporarily hold OutList(I)
   CHARACTER(*), PARAMETER      :: RoutineName = "KFAST_OS_SetOutParam"

   CHARACTER(OutStrLenM1), PARAMETER  :: ValidParamAry(45) =  (/ &                  ! This lists the names of the allowed parameters, which must be sorted alphabetically
                               "BGSRPITCH","BGSRPXI  ","BGSRPYI  ","BGSRPZI  ","BGSRROLL ","BGSRRVX  ","BGSRRVY  ", &
                               "BGSRRVZ  ","BGSRTAX  ","BGSRTAY  ","BGSRTAZ  ","BGSRTVX  ","BGSRTVY  ","BGSRTVZ  ", &
                               "BGSRYAW  ","BIMUPITCH","BIMUPXI  ","BIMUPYI  ","BIMUPZI  ","BIMUROLL ","BIMURVX  ", &
                               "BIMURVY  ","BIMURVZ  ","BIMUTAX  ","BIMUTAY  ","BIMUTAZ  ","BIMUTVX  ","BIMUTVY  ", &
                               "BIMUTVZ  ","BIMUYAW  ","BUOYHEAVE","BUOYPITCH","BUOYROLL ","BUOYRVX  ","BUOYRVY  ", &
                               "BUOYRVZ  ","BUOYSURGE","BUOYSWAY ","BUOYTAX  ","BUOYTAY  ","BUOYTAZ  ","BUOYTVX  ", &
                               "BUOYTVY  ","BUOYTVZ  ","BUOYYAW  "/)
   INTEGER(IntKi), PARAMETER :: ParamIndxAry(45) =  (/ &                            ! This lists the index into AllOuts(:) of the allowed parameters ValidParamAry(:)
                                BGSRPitch ,   BGSRPxi ,   BGSRPyi ,   BGSRPzi ,  BGSRRoll ,   BGSRRVx ,   BGSRRVy , &
                                  BGSRRVz ,   BGSRTAx ,   BGSRTAy ,   BGSRTAz ,   BGSRTVx ,   BGSRTVy ,   BGSRTVz , &
                                  BGSRYaw , BIMUPitch ,   BIMUPxi ,   BIMUPyi ,   BIMUPzi ,  BIMURoll ,   BIMURVx , &
                                  BIMURVy ,   BIMURVz ,   BIMUTAx ,   BIMUTAy ,   BIMUTAz ,   BIMUTVx ,   BIMUTVy , &
                                  BIMUTVz ,   BIMUYaw , BuoyHeave , BuoyPitch ,  BuoyRoll ,   BuoyRVx ,   BuoyRVy , &
                                  BuoyRVz , BuoySurge ,  BuoySway ,   BuoyTAx ,   BuoyTAy ,   BuoyTAz ,   BuoyTVx , &
                                  BuoyTVy ,   BuoyTVz ,   BuoyYaw /)
   CHARACTER(ChanLen), PARAMETER :: ParamUnitsAry(45) =  (/ &                     ! This lists the units corresponding to the allowed parameters
                               "deg       ","m         ","m         ","m         ","deg       ","deg/s     ","deg/s     ", &
                               "deg/s     ","m/s^2     ","m/s^2     ","m/s^2     ","m/s       ","m/s       ","m/s       ", &
                               "deg       ","deg       ","m         ","m         ","m         ","deg       ","deg/s     ", &
                               "deg/s     ","deg/s     ","m/s^2     ","m/s^2     ","m/s^2     ","m/s       ","m/s       ", &
                               "m/s       ","deg       ","m         ","deg       ","deg       ","deg/s     ","deg/s     ", &
                               "deg/s     ","m         ","m         ","m/s^2     ","m/s^2     ","m/s^2     ","m/s       ", &
                               "m/s       ","m/s       ","deg       "/)


      ! Initialize values
   ErrStat = ErrID_None
   ErrMsg = ""
   InvalidOutput = .FALSE.


!   ..... Developer must add checking for invalid inputs here: .....

!   ................. End of validity checking .................


   !-------------------------------------------------------------------------------------------------
   ! Allocate and set index, name, and units for the output channels
   ! If a selected output channel is not available in this module, set error flag.
   !-------------------------------------------------------------------------------------------------

   ALLOCATE ( p%OutParam(0:NumOuts) , STAT=ErrStat2 )
   IF ( ErrStat2 /= 0_IntKi )  THEN
      CALL SetErrStat( ErrID_Fatal,"Error allocating memory for the KiteFAST_OS OutParam array.", ErrStat, ErrMsg, RoutineName )
      RETURN
   ENDIF

      ! Set index, name, and units for the time output channel:

   p%OutParam(0)%Indx  = Time
   p%OutParam(0)%Name  = "Time"    ! OutParam(0) is the time channel by default.
   p%OutParam(0)%Units = "(s)"
   p%OutParam(0)%SignM = 1


      ! Set index, name, and units for all of the output channels.
      ! If a selected output channel is not available by this module set ErrStat = ErrID_Warn.

   DO I = 1,p%NumOuts

      p%OutParam(I)%Name  = OutList(I)
      OutListTmp          = OutList(I)

      ! Reverse the sign (+/-) of the output channel if the user prefixed the
      !   channel name with a "-", "_", "m", or "M" character indicating "minus".


      CheckOutListAgain = .FALSE.

      IF      ( INDEX( "-_", OutListTmp(1:1) ) > 0 ) THEN
         p%OutParam(I)%SignM = -1                         ! ex, "-TipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)
      ELSE IF ( INDEX( "mM", OutListTmp(1:1) ) > 0 ) THEN ! We'll assume this is a variable name for now, (if not, we will check later if OutListTmp(2:) is also a variable name)
         CheckOutListAgain   = .TRUE.
         p%OutParam(I)%SignM = 1
      ELSE
         p%OutParam(I)%SignM = 1
      END IF

      CALL Conv2UC( OutListTmp )    ! Convert OutListTmp to upper case


      Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )


         ! If it started with an "M" (CheckOutListAgain) we didn't find the value in our list (Indx < 1)

      IF ( CheckOutListAgain .AND. Indx < 1 ) THEN    ! Let's assume that "M" really meant "minus" and then test again
         p%OutParam(I)%SignM = -1                     ! ex, "MTipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)

         Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )
      END IF


      IF ( Indx > 0 ) THEN ! we found the channel name
         p%OutParam(I)%Indx     = ParamIndxAry(Indx)
         IF ( InvalidOutput( ParamIndxAry(Indx) ) ) THEN  ! but, it isn't valid for these settings
            p%OutParam(I)%Units = "INVALID"
            p%OutParam(I)%SignM = 0
         ELSE
            p%OutParam(I)%Units = ParamUnitsAry(Indx) ! it's a valid output
         END IF
      ELSE ! this channel isn't valid
         p%OutParam(I)%Indx  = Time                 ! pick any valid channel (I just picked "Time" here because it's universal)
         p%OutParam(I)%Units = "INVALID"
         p%OutParam(I)%SignM = 0                    ! multiply all results by zero

         CALL SetErrStat(ErrID_Fatal, TRIM(p%OutParam(I)%Name)//" is not an available output channel.",ErrStat,ErrMsg,RoutineName)
      END IF

   END DO

   RETURN
END SUBROUTINE KFAST_OS_SetOutParam
!----------------------------------------------------------------------------------------------------------------------------------
!End of code generated by Matlab script
!**********************************************************************************************************************************   
end module KiteFAST_OS_IO